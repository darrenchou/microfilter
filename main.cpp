//***************************************************************************
//                          main.cpp  -  description
//                             -------------------
//  begin            : Mon Oct 23 14:34:27 2017
//  generated by     : pvdevelop (C) Lehrig Software Engineering
//  email            : lehrig@t-online.de
//***************************************************************************

#include "pvapp.h"
#include "shamemchl.h"
// todo: comment me out. you can insert these objects as extern in your masks.
// Change "modbus"(Change if applicable) and "modbusdaemon_" with the "name" of your file "name.mkmodbus".
//rlModbusClient     modbus(modbusdaemon_MAILBOX,modbusdaemon_SHARED_MEMORY,modbusdaemon_SHARED_MEMORY_SIZE);
//rlSiemensTCPClient siemensTCP(siemensdaemon_MAILBOX,siemensdaemon_SHARED_MEMORY,siemensdaemon_SHARED_MEMORY_SIZE);
//rlPPIClient        ppi(ppidaemon_MAILBOX,ppidaemon_SHARED_MEMORY,ppidaemon_SHARED_MEMORY_SIZE);
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdarg.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <signal.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "osornoconf.h"
#include "pthread.h"
#include "oscadaserv.h"
#include "logger.h"
#include "simpledate.h"
#include "dispatcher.h"
#define PORT 7891

plc_to_pvs_t *stp2pvs = NULL;
pvs_to_plc_t *pvs2stp = NULL;
global_flags_t *globs   = NULL;
int stp_pid        = 3;
int status_change = 0;

unsigned long log_line_count = 0;

int dispatcher_pid = 0;

extern void plc_server_new();
extern void scada_dispatcher();
//extern void server2();

chlorine_conf_t config;
cfg_t *cfg = NULL;
ldap_conf_t   *ldap_config = NULL;
event_request_t *eve_request[EVE_MAX_NUMBER];
event_dsptch_t  *eve_proceed[EVE_MAX_NUMBER];
ip_config_t   *ip_opts[NUM_CONFIG_IP];
bool_config_t *bin_opts[NUM_CONFIG_BIN];
int_config_t  *int_opts[NUM_CONFIG_INT];

devstat_t *devstatList[MAX_DEV_NUM];
struct stat last_attr;
info_msg_tbl_t *msg_tbl = NULL; 
ConnectedClient connected_clients[MAX_NUM_CLIENTS];
//global_flags_t *globs   = NULL;

int block_local_client = 0;

void init_config()
{
  char opt_name[32];
  char ip_addr[32];
  char buf[512] = "";
  int  conf_err_num = 0;
  long int min_val = 0, max_val = 0, cur_val = 0;
  int reverse_logic = 0, normal_inactive = 0, ack_needed = 0;
  int attempts_change_fixed = 0;

  /*printf("LDAP CONFIGURATION OPTIONS:\n");
  ///printf("plant_name = %s\n", config.plant_name);
  printf("user_login = %s\n", config.user_login);
  printf("oper_login = %s\n", config.oper_login);
  printf("serv_login = %s\n", config.serv_login);
  printf("ldap_prime = %s\n", config.ldap_prime);
  printf("ldapsecond = %s\n", config.ldapsecond);
  printf("prime_cred = %s\n", config.prime_cred);
  printf("local_cred = %s\n", config.local_cred);
  printf("emrgemail1 = %s\n", config.emrgemail);
  */
  ///printf("emrgemail1 = %s\n", config.emrgemail1);
  ///printf("emrgemail2 = %s\n", config.emrgemail2);
  /*
  printf("MYSQL CONFIGURATION OPTIONS:\n");
  printf("mysql_user = %s\n"  , db_config->mysql_user);
  printf("mysql_dbname = %s\n", db_config->mysql_dbname);
  */
  /*printf("NETWORK CONFIGURATION OPTIONS:\n");
  for (int i = 0; i < NUM_CONFIG_IP; i++){
     sprintf(opt_name,  "%s", ip_opts[i]->name);
     sprintf(ip_addr,   "%s", ip_opts[i]->ip);
     printf("%s\t= %s\n" , opt_name, ip_addr);
  }
  */
  printf("BOLEAN CONFIGURATION OPTIONS:\n");
  for (int i = 0; i < NUM_CONFIG_BIN; i++){
     sprintf(opt_name, "%s", bin_opts[i]->name);
     printf("%s\t= %ld\n", opt_name, bin_opts[i]->cur_val);
     if (bin_opts[i]->fixed){
        if (bin_opts[i]->cur_val != init_bin_opts[i].cur_val){
           bin_opts[i]->cur_val = init_bin_opts[i].cur_val;
           (attempts_change_fixed > 0)? strcat (buf,",'"): strcat (buf,"'");
           strcat (buf, opt_name);
           strcat (buf,"'");
           attempts_change_fixed += 1;
        }
     }
  }
  
  printf("ADJUSTABLE INTEGER OPTIONS:\n");
  for (int i = 0; i < NUM_CONFIG_INT; i++){
     sprintf(opt_name, "%s", int_opts[i]->name);
     cur_val = int_opts[i]->cur_val;

     if (udjustable_min_max_int_option(i)){
       //! printing integer options with boundaries:
       //! boundary values could be changed just manualy by editing config-file
       min_val = int_opts[i]->lo_bound;
       max_val = int_opts[i]->hi_bound;
       printf("%s\t= {%ld, %ld, %ld}\n", opt_name,cur_val,min_val,max_val);
     } else {
       printf("%s\t= %ld\n", opt_name,cur_val);
     }
     if (int_opts[i]->fixed){
        if (int_opts[i]->cur_val != init_int_opts[i].cur_val){
           int_opts[i]->cur_val = init_int_opts[i].cur_val;
           (attempts_change_fixed > 0)? strcat (buf,",'"): strcat (buf,"'");
           strcat (buf, opt_name);
           strcat (buf,"'");
           attempts_change_fixed += 1;
        }
     }
  }
  
  if (attempts_change_fixed > 0){
     event_request_info(EVE_ATTEMPT_CHANGE_FIXED, INIT_EVENT, buf);
  }
  /*
  if (bin_opts[BUILD_ALARMS]->cur_val){
     bld_alarms_num = init_bld_alrm_conf();
     if (bld_alarms_num > 0){
        printf("BUILDING ALARMS OPTIONS:\n");
        for (int i = 0; i < bld_alarms_num; i++){
            reverse_logic   = bld_alrm_opts[i].reverse_logic;
            normal_inactive = bld_alrm_opts[i].normal_inactive;
            ack_needed      = bld_alrm_opts[i].alarm_ack;
            printf("%s\t\t= { %d, %d, %d }\n", bld_alrm_opts[i].alarm_name,
                               reverse_logic, normal_inactive, ack_needed);
        }
     }
  }
  */
  map_cur_config_values_to_new();
  conf_err_num = config_critical_err_status(0);
  printf("main(): number of config errors = %d\n", conf_err_num);
  
  save_bin_config_csv();
  save_int_config_csv();
  
}

void read_config()
{
  /*config.client_ip       = NULL;
  config.user_login      = NULL;
  config.oper_login      = NULL;
  ///config.admin_login     = NULL;
  config.service_login   = NULL;
  config.ldap_primary    = NULL;
  config.ldap_secondary  = NULL;
  config.prime_ldap_cred = NULL;
  config.local_ldap_cred = NULL;
  config.emergencyemail  = NULL;
  */
  cfg_opt_t opts[] = {   
     //CFG_STR ("client_ip",   config.client_ip, CFGF_NONE),
     //CFG_STR ((char*)"client_ip", "heyjay", CFGF_NONE),
     CFG_SIMPLE_STR ((char *)"server_ip",     &config.server_ip),
     CFG_SIMPLE_STR ((char *)"client_ip",     &config.client_ip),
     CFG_SIMPLE_STR ((char *)"user_login",    &(config.user_login)),
     CFG_SIMPLE_STR ((char *)"oper_login",    &(config.oper_login)),
     ///CFG_SIMPLE_STR ((char *)"admin_login",     &(config.admin_login)),
     CFG_SIMPLE_STR ((char *)"serv_login",    &(config.serv_login)),
     CFG_SIMPLE_STR ((char *)"ldap_prime",    &(config.ldap_prime)),
     CFG_SIMPLE_STR ((char *)"ldapsecond",    &(config.ldapsecond)),
     CFG_SIMPLE_STR ((char *)"prime_cred",    &(config.prime_cred)),
     CFG_SIMPLE_STR ((char *)"local_cred",    &(config.local_cred)),
     CFG_SIMPLE_STR ((char *)"emrgemail1",    &(config.emrgemail1)),

     //boolean options
    
     ///CFG_SIMPLE_INT((char*)"build_alarms",   &(bin_opts[BUILD_ALARMS]->cur_val)),
     CFG_SIMPLE_INT((char*)"PS1_present",       &(bin_opts[PS1_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"PS2_present",       &(bin_opts[PS2_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"PS_AIR_present",    &(bin_opts[PS_AIR_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"MagmIN_present",    &(bin_opts[MAGMIN_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"MagmOUT_present",   &(bin_opts[MAGMOUT_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"CIP_present",       &(bin_opts[PS_AIR_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"reservoir_present", &(bin_opts[RESERVOIR_PRESENT]->cur_val)),
     
     CFG_SIMPLE_INT((char*)"sol_S1_present",    &(bin_opts[SOL_S1_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"sol_S2_present",    &(bin_opts[SOL_S2_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"sol_S3_present",    &(bin_opts[SOL_S3_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"sol_S4_present",    &(bin_opts[SOL_S4_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"sol_S5_present",    &(bin_opts[SOL_S5_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"sol_S6_present",    &(bin_opts[SOL_S6_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"uF1_present",       &(bin_opts[UF1_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"uF2_present",       &(bin_opts[UF2_PRESENT]->cur_val)),
     CFG_SIMPLE_INT((char*)"dp_present",        &(bin_opts[DP_PRESENT]->cur_val)),
     
     CFG_SIMPLE_INT((char*)"config_force",   &(bin_opts[CONFIG_FORCE]->cur_val)),
     //int options 
     CFG_INT_LIST((char*)"max_magmIN_flow", 0, CFGF_NONE),
     CFG_INT_LIST((char*)"magmIN_pulse_value", 0, CFGF_NONE),
     CFG_INT_LIST((char*)"max_magmOUT_flow", 0, CFGF_NONE),
     CFG_INT_LIST((char*)"magmOUT_pulse_value", 0, CFGF_NONE),

     //CFG_SIMPLE_INT((char*)"ch1a_sensors", &(bin_opts[CH1A_SENSORS]->cur_val)),
     CFG_STR("target", "World", CFGF_NONE),
     CFG_END()
  };
  
  cfg = cfg_init(opts, 0);

  //cfg_parse(cfg, CONFIG_FILE);
  if(cfg_parse(cfg, CONFIG_FILE) == CFG_PARSE_ERROR)
    printf("\nConfiguration is failed");

  /*
  //! initialization config file timestamp attributes:
  memset(&last_attr, 0, sizeof(last_attr));
  */
  printf("read configuration\n");
  printf("Configuration ip is  %s\n", cfg_getstr(cfg, "client_ip"));
  printf("Configuration emergencyemail is  %s\n", cfg_getstr(cfg, "emrgemail1"));
  printf("Configuration emergencyemail2 is  %s\n", config.emrgemail1);
  //printf("Configuration admin_login is  %s\n", cfg_getstr(cfg, "admin_login"));
  printf("Target is  %s\n", cfg_getstr(cfg, "target"));
  
  int_opts[MAX_MAGMIN_FLOW]->cur_val  = cfg_getnint(cfg,  "max_magmIN_flow", 0);
  int_opts[MAX_MAGMIN_FLOW]->lo_bound  = cfg_getnint(cfg, "max_magmIN_flow", 1);
  int_opts[MAX_MAGMIN_FLOW]->hi_bound  = cfg_getnint(cfg, "max_magmIN_flow", 2);

  int_opts[MAGMIN_PULSE_VALUE]->cur_val  = cfg_getnint(cfg, "magmIN_pulse_value", 0);
  int_opts[MAGMIN_PULSE_VALUE]->lo_bound  = cfg_getnint(cfg, "magmIN_pulse_value", 1);
  int_opts[MAGMIN_PULSE_VALUE]->hi_bound  = cfg_getnint(cfg, "magmIN_pulse_value", 2);

  int_opts[MAX_MAGMOUT_FLOW]->cur_val  = cfg_getnint(cfg, "max_magmOUT_flow", 0);
  int_opts[MAX_MAGMOUT_FLOW]->lo_bound  = cfg_getnint(cfg, "max_magmOUT_flow", 1);
  int_opts[MAX_MAGMOUT_FLOW]->hi_bound  = cfg_getnint(cfg, "max_magmOUT_flow", 2);

  int_opts[MAGMOUT_PULSE_VALUE]->cur_val  = cfg_getnint(cfg, "magmOUT_pulse_value", 0);
  int_opts[MAGMOUT_PULSE_VALUE]->lo_bound  = cfg_getnint(cfg, "magmOUT_pulse_value", 1);
  int_opts[MAGMOUT_PULSE_VALUE]->hi_bound  = cfg_getnint(cfg, "magmOUT_pulse_value", 2);
 
  printf("magmin_pulse_value hi_bound is  %d\n", int_opts[MAGMIN_PULSE_VALUE]->hi_bound);
  
  int j = is_a_leap_year(2000);
  printf("leap year  %d\n", j);
  //test logger.h 
  printf("log number is  %d\n",  LOG_MSG_INFO);
  //log_init();
  //cfg_free(cfg);
  printf("LDAP CONFIGURATION OPTIONS:\n");
  ///printf("plant_name = %s\n", config.plant_name);
  printf("user_login = %s\n", config.user_login);
  printf("oper_login = %s\n", config.oper_login);
  printf("serv_login = %s\n", config.serv_login);
  printf("ldap_prime = %s\n", config.ldap_prime);
  printf("ldapsecond = %s\n", config.ldapsecond);
  printf("prime_cred = %s\n", config.prime_cred);
  printf("local_cred = %s\n", config.local_cred);
  printf("emrgemail1 = %s\n", config.emrgemail1);
}

//!****************************************************************************
void close_pvs_session()
{
  if (ldap_config != NULL) {
     munmap(ldap_config, sizeof(ldap_conf_t));
  }

  /*if (db_config != NULL) {
     munmap(db_config, sizeof(mysql_conf_t));
  }
  */
  for (int i = 0; i < EVE_MAX_NUMBER; i++){
      if (eve_request[i] != NULL){
         munmap(eve_request[i], sizeof(event_request_t));
         munmap(eve_proceed[i], sizeof(event_dsptch_t));
      }
  }
  for (int i = 0; i < MAX_DEV_NUM; i++){
      if (devstatList[i] != NULL){
         munmap(devstatList[i], sizeof(devstat_t));
      }
  }
  if (stp2pvs != NULL) {
      munmap(stp2pvs, sizeof(plc_to_pvs_t));
      stp2pvs = NULL;
  }
  if (pvs2stp != NULL) {
      munmap(pvs2stp, sizeof(pvs_to_plc_t));
      pvs2stp = NULL;
  }
  
  if (msg_tbl != NULL) {
     munmap(msg_tbl, sizeof(info_msg_tbl_t));
  }
  //!----------------------------------------------------
  /*if (cfg != NULL) {
       cfg_free(cfg);
  }
  */
  //! waiting for finishing child processes
  kill(stp_pid, SIGTERM);
  kill(dispatcher_pid, SIGTERM);
}


void init_shared_memory()
{
  //! OSAUT SCADA - PLC communication shared data
  pvs2stp = (pvs_to_plc_t *) mmap(NULL, sizeof(pvs_to_plc_t),
            PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);

  stp2pvs = (plc_to_pvs_t *) mmap(NULL, sizeof(plc_to_pvs_t),
            PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);

  memset(pvs2stp, 0, sizeof(pvs_to_plc_t));
  memset(stp2pvs, 0, sizeof(plc_to_pvs_t));
  

  //! info messages table
  msg_tbl = (info_msg_tbl_t *) mmap(NULL, sizeof(info_msg_tbl_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
  memset(msg_tbl, 0, sizeof(msg_tbl));

  //! system events table
  for (int i = 0; i < EVE_MAX_NUMBER; i++){
      eve_request[i] = (event_request_t *)mmap(NULL, sizeof(event_request_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
      eve_proceed[i] = (event_dsptch_t *)mmap(NULL, sizeof(event_dsptch_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);

      memset(eve_request[i], 0, sizeof(event_request_t));
      memset(eve_proceed[i], 0, sizeof(event_dsptch_t));
  }
  init_eve_request();
  init_eve_proceed();

  //! configuration tables
  
  for (int i = 0; i < NUM_CONFIG_IP; i++){
     ip_opts[i] = (ip_config_t *)mmap(NULL, sizeof(ip_config_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
     memset(ip_opts[i], 0, sizeof(ip_config_t));
  }
  for (int i = 0; i < NUM_CONFIG_BIN; i++){
     bin_opts[i] = (bool_config_t *)mmap(NULL, sizeof(bool_config_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
     memset(bin_opts[i], 0, sizeof(bool_config_t));
  }
  for (int i = 0; i < NUM_CONFIG_INT; i++){
     int_opts[i] = (int_config_t *)mmap(NULL, sizeof(int_config_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
     memset(int_opts[i], 0, sizeof(int_config_t));
  }
  init_ip_opts_tbl();
  init_bin_opts_tbl();
  init_int_opts_tbl();

  //! ldap configuration settings
  ldap_config = (ldap_conf_t *) mmap(NULL, sizeof(ldap_conf_t),
                  PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, 0, 0);
  memset(ldap_config, 0, sizeof(ldap_conf_t));

  //! devices states table (could be changed only by communication server)
  for (int i = 0; i < MAX_DEV_NUM; i++){
     devstatList[i] = (devstat_t *)mmap(NULL, sizeof(devstat_t),
                  PROT_READ | PROT_WRITE,  MAP_SHARED | MAP_ANONYMOUS, 0, 0);
     memset(devstatList[i], 0, sizeof(devstat_t));
  }
  init_devstat_tbl();
  printf("Memory has been initialized\n");
}

void init_plc_server()
{ 

  stp_pid = fork();

  if (stp_pid == 0) { //! child process creates plc-daemon
     printf("child process is created");
     stp2pvs->main_flow = 200;
     printf("sent value is %d\n", stp2pvs->main_flow);
     //server(); //previous server
     plc_server_new();
     //server2();
     exit(0);
  }

}

//!****************************************************************************
void init_dispatcher()
{
  //! Start Dispatcher
  dispatcher_pid = fork();

  if (dispatcher_pid == 0) { //! child process creates events-dispatcher daemon
     scada_dispatcher();
     exit(0);
  }
}

int pvMain(PARAM *p)
{
int ret;

  pvSendVersion(p);
  pvSetCaption(p,"osornod");
  pvResize(p,0,1280,1024);
  //pvScreenHint(p,1024,768); // this may be used to automatically set the zoomfactor
  ret = 1;
  pvGetInitialMask(p);
  if(strcmp(p->initial_mask,"mask1") == 0) ret = 1;

  while(1)
  {
    if(trace) printf("show_mask%d\n", ret);
    switch(ret)
    {
      case 7:
        pvStatusMessage(p,-1,-1,-1,"mask7");
        ret = show_mask7(p);
        break;
      case 6:
        pvStatusMessage(p,-1,-1,-1,"mask6");
        ret = show_mask6(p);
        break;
      case 5:
        pvStatusMessage(p,-1,-1,-1,"mask5");
        ret = show_mask5(p);
        break;
      case 4:
        pvStatusMessage(p,-1,-1,-1,"mask4");
        ret = show_mask4(p);
        break;
      case 3:
        pvStatusMessage(p,-1,-1,-1,"mask3");
        ret = show_mask3(p);
        break;
      case 2:
        pvStatusMessage(p,-1,-1,-1,"mask2");
        ret = show_mask2(p);
        break;
      case 1:
        pvStatusMessage(p,-1,-1,-1,"mask1");
        ret = show_mask1(p);
        break;
      default:
        return 0;
    }
  }
}

#ifdef USE_INETD
int main(int ac, char **av)
{
PARAM p;

  pvInit(ac,av,&p);
  /* here you may interpret ac,av and set p->user to your data */
  pvMain(&p);
  return 0;
}
#else  // multi threaded server
int main(int ac, char **av)
{
  PARAM p;
  int   s;
  log_init();
  
  init_shared_memory();
  //usleep(10000000);
  read_config();

  init_config();

  
  //! starting pls dispatcher process
  init_dispatcher();
  //stp2pvs->info = "12";
  init_plc_server();
  pvInit(ac,av,&p);
  /* here you may interpret ac,av and set p->user to your data */
  while(1)
  {
    s = pvAccept(&p);
    if(s != -1) pvCreateThread(&p,s);
  }
  return 0;
}
#endif
