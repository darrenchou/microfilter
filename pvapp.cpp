/*****************************************************************************
 * pvapp.cpp
 *                        --------------------------------------------
 *  begin                 : Mon Sep 23 14:48:00 2013
 *  template generated by : pvdevelop (C) Lehrig Software Engineering
 *  email                 : lehrig@t-online.de 
 *                        --------------------------------------------
 * This file is part of OSAUT and OSORNOD projects. OSAUT is a free definition,
 * ehich may be used under the Creative Commons Share-alike license with the
 * additional condition of notifying the original author(s) of deviations and
 * expansion of the work.OSORNOD is intended to be released in the near future
 * as free software that you then can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free 
 * Software Foundation, version 3. However,up to that point, OSORNOD software
 * and any or all of its components are proprietary and may not be modified or
 * distributed without express approval of Osorno Enterprises Inc.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * A copy of the GNU General Public License can be obtained from the Free 
 * Software Foundation, Inc., 51  Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA.
 *
 * Copyright Osorno Enterprises Inc., 2013
 *
 * OSAUT and OSORNOD project
 * (c) Osorno Enterprises Inc., 2013: http://www.osorno.ca/
 * 
 ****************************************************************************/
//+++++++++++++++
// 1. comment scada request function 
 //2. comment update_scada_config_from_plc()
//3.  comment map_plc_config_values_to_new()
 //4. comment plc_scada_config_accordance()    ----------- uncommented
 //5. comment save_config_err_info()
 //6. comment config_critical_err_status()    
 //7. comment update_plc_message
 //8. comment is_an_emergency
 //9. comment show_status_message
 //10 comment ui_save_new_config_setings   --------- uncommented
 //11. comment lift_st_level_value()
 //12. comment uv_percent_value
 //13. comment tank3_level_value
 //14. comment actuator_formula
 //15. comment sens_temperature_value
 //16. comment sens_pH_value
 //17. comment sens_orp_value
 //18. comment part of device_disconnected()......3 sensors
 //19. comment remove_client_disconnected
 //20. comment get_stp_sensors_state
 //21. comment min_magmeter_flow()
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include "pvapp.h"
#include "osaut.h"
#include "logger.h"
#include "shamemchl.h"
#include "osornoconf.h"
#include "dispatcher.h"
//#include "mathapi.h"

struct timeval start_request_time;
int plc_pvs_request_state = 0;

int next_plc_mode      = PLC_UNDEFINED;
int plc_requested_mode = PLC_UNDEFINED;
int current_plc_mode   = PLC_INACTIVE;

const char *months[12] = {
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
};
///modify this!!+++++++

devstat_t ini_devstatList[MAX_DEV_NUM] = {
   //! dev_id   exists manual enbled active in_err
   /*{ DEV_LIFT  ,    1,     0,      1,    0,     0 },   //! LIFT STATION
   { DEV_BLOW1A,    1,     0,      1,    0,     0 },   //! BLOWER 1A
   { DEV_BLOW1B,    1,     0,      1,    0,     0 },   //! BLOWER 1B
   { DEV_BLOW2 ,    1,     0,      1,    0,     0 },   //! BLOWER 2
   { DEV_PUMP1 ,    1,     0,      1,    0,     0 },   //! DISCHARGE PUMP 1
   { DEV_PUMP2 ,    1,     0,      1,    0,     0 },   //! DISCHARGE PUMP 2
   { DEV_UV    ,    1,     0,      1,    0,     0 },   //! UV-LAMP
   { DEV_SOL   ,    1,     0,      1,    0,     0 },   //! SOLENOID
   { DEV_ACT   ,    1,     0,      1,    0,     0 },   //! ACTUATOR
   { DEV_MAGM  ,    1,     0,      1,    0,     0 },   //! MAGMETER
   { DEV_T3SENS,    1,     0,      1,    0,     0 },   //! T3 LVL SENSOR
   { DEV_T3SW  ,    1,     0,      1,    0,     0 },   //! T3 LVL SWITCHES
   { DEV_FLOWSW,    1,     0,      1,    0,     0 },   //! OUTFLOW SWITCH
   { DEV_MAIN_L,    1,     0,      1,    0,     0 },   //! MAIN POWER LINE
   { DEV_PHASE1,    1,     0,      1,    0,     0 },   //! PHASE-1 POWER LINE
   { DEV_PHASE2,    1,     0,      1,    0,     0 },   //! PHASE-2 POWER LINE
   { DEV_PHASE3,    1,     0,      1,    0,     0 },   //! PHASE-3 POWER LINE
   { DEV_SENS1 ,    1,     0,      1,    0,     0 },   //! CHAMBER 1A SENSORS
   { DEV_SENS2 ,    1,     0,      1,    0,     0 },   //! CHAMBER 1B SENSORS
   { DEV_SENS3 ,    1,     0,      1,    0,     0 },   //! CHAMBER 3 SENSORS
   { DEV_SYS   ,    1,     0,      1,    0,     0 },   //! BIOCOMPACT SYSTEM
   */
   //new added++++++
   { DEV_SOL1  ,    1,     0,      1,    0,     0 },   //! SOL1
   { DEV_SOL2  ,    1,     0,      1,    0,     0 },   //! SOL2
   { DEV_SOL3  ,    1,     0,      1,    0,     0 },   //! SOL3
   { DEV_SOL4  ,    1,     0,      1,    0,     0 },   //! SOL4
   { DEV_SOL5  ,    1,     0,      1,    0,     0 },   //! SOL5
   { DEV_SOL6  ,    1,     0,      1,    0,     0 },   //! SOL6
   { DEV_SOL7  ,    1,     0,      1,    0,     0 },   //! SOL7
   { DEV_SOL8  ,    1,     0,      1,    0,     0 },   //! SOL8
   { DEV_SOL9  ,    1,     0,      1,    0,     0 },   //! SOL9

};



//!****************************************************************************
void init_devstat_tbl()
{
  for (int i = 0; i < MAX_DEV_NUM; i++){
     devstatList[i]->dev_id = ini_devstatList[i].dev_id;
     devstatList[i]->exists = ini_devstatList[i].exists;
     devstatList[i]->manual = ini_devstatList[i].manual;
     devstatList[i]->enbled = ini_devstatList[i].enbled;
     devstatList[i]->active = ini_devstatList[i].active;
     devstatList[i]->in_err = ini_devstatList[i].in_err;
  }
}

//!****************************************************************************
//! returns the minimum flow defined for magmeter in cubic meters per hour
//!****************************************************************************
/*
double min_magmeter_flow()
{
  int plc_connected = !(stp2pvs->no_connection);
  double min_flow   = MAGM_MINFLOW_DEFAULT;  //! in cubic meters per hour
  
  if (plc_connected){
     min_flow = ((double)stp2pvs->magm_minflow)/ DEF_FLOW_DIVIDER;
  } else {
     min_flow = ((double)int_opts[MAGM_MINFLOW]->cur_val)/ DEF_FLOW_DIVIDER;
  }
  return min_flow;
}
*/
//!****************************************************************************
//! returns the maximum flow defined for magmeter in cubic meters per hour
//!****************************************************************************
double max_magmeter_flow()
{
  int plc_connected = !(stp2pvs->no_connection);
  double max_flow   = MAGM_MAXFLOW_DEFAULT;  //! in cubic meters per hour
  
  if (plc_connected){
    //++++++++change stp2pvs  to  pvs2stp....where should max_magmIN_flow belong to?
     max_flow = ((double)pvs2stp->max_magmIN_flow);
  } else {
     max_flow = ((double)int_opts[MAX_MAGMIN_FLOW]->cur_val);
  }
  return max_flow;
}

//!****************************************************************************
//! returns poop-flow registred by magmeter in cubic meters per hour
//!****************************************************************************
double actual_magmeter_flow()
{
  //++++++++ change magmeter_flow  to  magmeterIN
  word flow_input   = stp2pvs->magmeterIN;
  double cur_flow   = 0.0;  //! in cubic meters per hour

  if (stp2pvs->magm_no_sign != 1){
     cur_flow = ((double)(flow_input)*max_magmeter_flow())/ DEF_FLOW_DIVIDER;
  }
  return cur_flow;
}

//!****************************************************************************
int is_config_file_modified() {
  struct stat new_attr;
  
  stat(CONFIG_FILE, &new_attr);
  
  printf("Last modified time: %s", ctime(&last_attr.st_mtime));
  printf("New  modified time: %s", ctime(&new_attr.st_mtime));
  
  if (strcmp(ctime(&last_attr.st_mtime), ctime(&new_attr.st_mtime)) == 0){
     return 0;
  } else {
     stat(CONFIG_FILE, &last_attr);
     return 1;
  }
}

//!****************************************************************************
/*
int scada_request_resolved(int eve_id)
{
  int resolved = 0, msg_val = 0;
  int new_msg  = (stp2pvs->update != pvs2stp->update);

  switch (eve_id){
     case EVE_UPDATE_SYSTEM_DATA:
     case EVE_CONFIG_SCADA_TO_PLC:
     case EVE_CONFIG_UIMAN_TO_PLC:
          resolved = (new_msg && stp2pvs->save_data_stat == 0
                              && pvs2stp->save_data_cmd  != 1);
          break;
          
     case EVE_SERVICE_START:
          resolved = (new_msg && stp2pvs->service_mode == 1);
          break;
          
     case EVE_SERVICE_FINISH: 
          resolved = (new_msg && stp2pvs->service_mode == 0);
          break;
          
     case EVE_SERVICE_STP_START:
          resolved = (new_msg && stp2pvs->start_plant_stat == 0
                              && pvs2stp->start_plant_cmd != 1);
          break;
          
     case EVE_SERVICE_STP_STOP:
          resolved = (new_msg && stp2pvs->stop_plant_stat == 0
                              && pvs2stp->stop_plant_cmd != 1);
          break;
          
     case EVE_SERVICE_ALL_TO_MAN: msg_val = 1;
     case EVE_SERVICE_ALL_TO_AUTO:
          resolved = (new_msg && stp2pvs->manual_on == msg_val &&
          //! if((device exists   AND     particular request was resolved)       OR  device does not exist)
          ((stp2pvs->blower1a_opt && (new_msg && stp2pvs->bl1a_mode == msg_val)) || !stp2pvs->blower1a_opt) &&
          ((stp2pvs->blower1b_opt && (new_msg && stp2pvs->bl1b_mode == msg_val)) || !stp2pvs->blower1b_opt) &&
          ((stp2pvs->blower2_opt  && (new_msg && stp2pvs->bl2_mode  == msg_val)) || !stp2pvs->blower2_opt ) &&
          ((stp2pvs->uv_unit_opt  && (new_msg && stp2pvs->uv_mode   == msg_val)) || !stp2pvs->uv_unit_opt ) &&
          ((stp2pvs->solenoid_opt && (new_msg && stp2pvs->sol_mode  == msg_val)) || !stp2pvs->solenoid_opt) &&
          ((stp2pvs->actuator_opt && (new_msg && stp2pvs->act_mode  == msg_val)) || !stp2pvs->actuator_opt) &&
          ((stp2pvs->lift_station && (new_msg && stp2pvs->lift_mode == msg_val)) || !stp2pvs->lift_station) &&
          //! for pumps condition little bit different: should exist at least one pump
          ((stp2pvs->t3_pump1_opt || stp2pvs->t3_pump1_opt) && (new_msg && stp2pvs->pumps_mode == msg_val)));
          break;
          
     case EVE_SERVICE_ERR_ACK:
          resolved = (new_msg && stp2pvs->error_ack_stat == 0
                              && pvs2stp->error_ack_cmd != 1);
          break;

     case EVE_SERVICE_PC_REBOOT:
          resolved = (new_msg && stp2pvs->pc_reboot_stat == 0
                              && pvs2stp->pc_reboot_cmd  != 1);
          break;

          //!  manual/auto modes:
     case EVE_INTO_MAN_BL1A: msg_val = 1;
     case EVE_INTO_AUTO_BL1A:
          resolved = (new_msg && stp2pvs->bl1a_mode == msg_val);
          break;
     case EVE_INTO_MAN_BL1B: msg_val = 1;
     case EVE_INTO_AUTO_BL1B:
          resolved = (new_msg && stp2pvs->bl1b_mode == msg_val);
          break;
     case EVE_INTO_MAN_BL2: msg_val = 1;
     case EVE_INTO_AUTO_BL2:
          resolved = (new_msg && stp2pvs->bl2_mode == msg_val);
          break;
     case EVE_INTO_MAN_PUMPS: msg_val = 1;
     case EVE_INTO_AUTO_PUMPS:
          resolved = (new_msg && stp2pvs->pumps_mode == msg_val);
          break;
     case EVE_INTO_MAN_UV: msg_val = 1;
     case EVE_INTO_AUTO_UV:
          resolved = (new_msg && stp2pvs->uv_mode == msg_val);
          break;
     case EVE_INTO_MAN_SOL: msg_val = 1;
     case EVE_INTO_AUTO_SOL:
          resolved = (new_msg && stp2pvs->sol_mode == msg_val);
          break;
     case EVE_INTO_MAN_ACT: msg_val = 1;
     case EVE_INTO_AUTO_ACT:
          resolved = (new_msg && stp2pvs->act_mode == msg_val);
          break;
     case EVE_INTO_MAN_LIFT: msg_val = 1;
     case EVE_INTO_AUTO_LIFT:
          resolved = (new_msg && stp2pvs->lift_mode == msg_val);
          break;

          //! enable/disable devices
     case EVE_INTO_ENBL_BL1A: msg_val = 1;
     case EVE_INTO_DIS_BL1A:
          resolved = (new_msg && stp2pvs->bl1a_powered == msg_val);
          break;
     case EVE_INTO_ENBL_BL1B: msg_val = 1;
     case EVE_INTO_DIS_BL1B:
          //printf ("scada_request_resolved(): stp2pvs->bl1b_powered = %d\n", stp2pvs->bl1b_powered);
          resolved = (new_msg && stp2pvs->bl1b_powered == msg_val);
          break;
     case EVE_INTO_ENBL_BL2: msg_val = 1;
     case EVE_INTO_DIS_BL2:
          resolved = (new_msg && stp2pvs->bl2_powered == msg_val);
          break;
     case EVE_INTO_ENBL_PUMP1: msg_val = 1;
     case EVE_INTO_DIS_PUMP1:
          resolved = (new_msg && stp2pvs->pump1_powered == msg_val);
          break;
     case EVE_INTO_ENBL_PUMP2: msg_val = 1;
     case EVE_INTO_DIS_PUMP2:
          resolved = (new_msg && stp2pvs->pump2_powered == msg_val);
          break;
     case EVE_INTO_ENBL_UV: msg_val = 1;
     case EVE_INTO_DIS_UV:
          resolved = (new_msg && stp2pvs->uv_powered == msg_val);
          break;
     case EVE_INTO_ENBL_SOL: msg_val = 1;
     case EVE_INTO_DIS_SOL:
          resolved = (new_msg && stp2pvs->sol_powered == msg_val);
          break;
     case EVE_INTO_ENBL_LIFT: msg_val = 1;
     case EVE_INTO_DIS_LIFT:
          resolved = (new_msg && stp2pvs->lift_powered == msg_val);
          break;

          //! enable/disable devices
     case EVE_SWITCH_ON_BL1A: msg_val = 1;
     case EVE_SWITCH_OFF_BL1A:
          resolved = (new_msg && stp2pvs->bl1a_started == msg_val);
          break;
     case EVE_SWITCH_ON_BL1B: msg_val = 1;
     case EVE_SWITCH_OFF_BL1B:
          resolved = (new_msg && stp2pvs->bl1b_started == msg_val);
          break;
     case EVE_SWITCH_ON_BL2: msg_val = 1;
     case EVE_SWITCH_OFF_BL2:
          resolved = (new_msg && stp2pvs->bl2_started == msg_val);
          break;
     case EVE_SWITCH_ON_PUMP1: msg_val = 1;
     case EVE_SWITCH_OFF_PUMP1:
          resolved = (new_msg && stp2pvs->pump1_started == msg_val);
          break;
     case EVE_SWITCH_ON_PUMP2: msg_val = 1;
     case EVE_SWITCH_OFF_PUMP2:
          resolved = (new_msg && stp2pvs->pump2_started == msg_val);
          break;
     case EVE_SWITCH_ON_UV: msg_val = 1;
     case EVE_SWITCH_OFF_UV:
          resolved = (new_msg && stp2pvs->uv_started == msg_val);
          break;
     case EVE_SWITCH_ON_SOL: msg_val = 1;
     case EVE_SWITCH_OFF_SOL:
          resolved = (new_msg && stp2pvs->sol_started == msg_val);
          break;
     case EVE_SWITCH_ON_LIFT: msg_val = 1;
     case EVE_SWITCH_OFF_LIFT:
          resolved = (new_msg && stp2pvs->lift_started == msg_val);
          break;

          //! actuator step up/down
     case EVE_ACTUATOR_STEP_UP:
          resolved = (new_msg && stp2pvs->act_step_up == 0 && pvs2stp->act_step_up != 1);
          break;
     case EVE_ACTUATOR_STEP_DOWN:
          resolved = (new_msg && stp2pvs->act_step_down == 0 && pvs2stp->act_step_down != 1);
          break;

  }
  if (resolved){
     printf("scada_request_resolved(): REQUEST RESOLVED !\n");
  }
  return resolved;
}
*/
//!****************************************************************************
//! this function should be called from dispatcher during WAITING_EVENT status
//! of the event processing mode
//!****************************************************************************
//! parameters: 'id' - event id value 
//!****************************************************************************
//! returns:  '1' - if request to plc was successfully resolved
//!           '0' - if request to plc is processing
//!          '-1' - if request to plc was timed out
//!****************************************************************************
int monitoring_scada_plc_request(int id)
{
  struct timeval t1;
  //!  for debuging purposes only
  static int msg_printed = 0;
  //+++++++++++++++++++
  //if (scada_request_resolved(id)){
  if (1){// +++++++++++
     if (id == EVE_CONFIG_SCADA_TO_PLC || EVE_CONFIG_UIMAN_TO_PLC){
        //! drop off force config save flag
        bin_opts[CONFIG_FORCE]->cur_val = 0;
        //! save changes into scada config file 
        save_bio_c_conf_bin();
        save_bio_c_conf_int();
        //! save changes into *.csv (config tables)
        save_bin_config_csv();
        save_int_config_csv();
        
        msg_printed = 0;
     }
     return 1;
  } else {
     gettimeofday(&t1, 0);
     if (ms_diff(&start_request_time, &t1) < 1500){
     //! events that should be returned into zero-status state to be resolved
        if((id == EVE_CONFIG_SCADA_TO_PLC && stp2pvs->save_data_stat   == 1) ||
           (id == EVE_CONFIG_UIMAN_TO_PLC && stp2pvs->save_data_stat   == 1) ||
           (id == EVE_SERVICE_STP_START   && stp2pvs->start_plant_stat == 1) ||
           (id == EVE_SERVICE_STP_STOP    && stp2pvs->stop_plant_stat  == 1) ||
           (id == EVE_SERVICE_PC_REBOOT   && stp2pvs->pc_reboot_stat   == 1) ||
           (id == EVE_SERVICE_ERR_ACK     && stp2pvs->error_ack_stat   == 1) 
           //++++++++++
           //(id == EVE_ACTUATOR_STEP_UP    && stp2pvs->act_step_up      == 1) ||
           //(id == EVE_ACTUATOR_STEP_DOWN  && stp2pvs->act_step_down    == 1)
           ){
           //!  just for debuging purposes
           if (!msg_printed){
              printf("monitoring_scada_plc_request() request to drop flag!\n");
              msg_printed = 1;
           }
           //+++++++++++++++++++++++++
           //update_plc_message(id, 0);
        } 
     } else {
        msg_printed = 0;

        return -1;
     }
  }
  return 0;
}

//!****************************************************************************
void scada_plc_send_request(int id, int value)
{
  gettimeofday(&start_request_time, 0);
  printf("scada_plc_send_request() id = %d, event value = %d\n", id, value);
  //++++++++++++++++++++++
  //update_plc_message(id, value);
}
/*
//!****************************************************************************
void update_scada_config_from_plc()
{
  //! remaping configuration from PLC OSAUT message to SCADA
  //! boolean options
  bin_opts[LIFT_STATION]->cur_val = stp2pvs->lift_station;
  bin_opts[LIFT_ST_ETH ]->cur_val = stp2pvs->lift_eth    ;
  bin_opts[LIFT_SENSOR ]->cur_val = stp2pvs->lift_sensor ;
  bin_opts[ACTUATOR_OPT]->cur_val = stp2pvs->actuator_opt;
  bin_opts[ACTUATOR_ETH]->cur_val = stp2pvs->actuator_eth;
  bin_opts[MAGMETER_OPT]->cur_val = stp2pvs->magmeter_opt;
  bin_opts[MAGMETER_ETH]->cur_val = stp2pvs->magmeter_eth;
  bin_opts[BLOWER1A_OPT]->cur_val = stp2pvs->blower1a_opt;
  bin_opts[BL1A_3_PHASE]->cur_val = stp2pvs->bl1a_3_phase;
  bin_opts[BL1A_S_START]->cur_val = stp2pvs->bl1a_s_start;
  bin_opts[BL1A_PRES_SW]->cur_val = stp2pvs->bl1a_pres_sw;
  bin_opts[BLOWER1B_OPT]->cur_val = stp2pvs->blower1b_opt;
  bin_opts[BL1B_3_PHASE]->cur_val = stp2pvs->bl1b_3_phase;
  bin_opts[BL1B_S_START]->cur_val = stp2pvs->bl1b_s_start;
  bin_opts[BL1B_PRES_SW]->cur_val = stp2pvs->bl1b_pres_sw;
  bin_opts[BLOWER2_OPT ]->cur_val = stp2pvs->blower2_opt ;
  bin_opts[BL2_3_PHASE ]->cur_val = stp2pvs->bl2_3_phase ;
  bin_opts[BL2_S_START ]->cur_val = stp2pvs->bl2_s_start ;
  bin_opts[BL2_PRES_SW ]->cur_val = stp2pvs->bl2_pres_sw ;
  bin_opts[ALTER_BLOW_2]->cur_val = stp2pvs->alter_blow_2;
  bin_opts[SOLENOID_OPT]->cur_val = stp2pvs->solenoid_opt;
  bin_opts[T3_SENS_OPT ]->cur_val = stp2pvs->t3_sens_opt ;
  bin_opts[T3_SENS_ETH ]->cur_val = stp2pvs->t3_sens_eth ;
  bin_opts[T3_HIGH_OPT ]->cur_val = stp2pvs->t3_high_opt ;
  bin_opts[T3_LOW_OPT  ]->cur_val = stp2pvs->t3_low_opt  ;
  bin_opts[T3_PUMP1_OPT]->cur_val = stp2pvs->t3_pump1_opt;
  bin_opts[T3_PUMP2_OPT]->cur_val = stp2pvs->t3_pump2_opt;
  bin_opts[ALTER_PUMPS ]->cur_val = stp2pvs->alter_pumps ;
  bin_opts[UV_UNIT_OPT ]->cur_val = stp2pvs->uv_unit_opt ;
  bin_opts[UV_UNIT_ETH ]->cur_val = stp2pvs->uv_unit_eth ;
  bin_opts[FLOW_SW_OPT ]->cur_val = stp2pvs->flow_sw_opt ;
  bin_opts[CONFIG_FORCE]->cur_val = 0;
  //! integer options
  int_opts[OFFTIME_BL1A]->cur_val = stp2pvs->offtime_bl1a;
  int_opts[ONTIME_BL1A ]->cur_val = stp2pvs->ontime_bl1a ;
  int_opts[OFFTIME_BL1B]->cur_val = stp2pvs->offtime_bl1b;
  int_opts[ONTIME_BL1B ]->cur_val = stp2pvs->ontime_bl1b ;
  int_opts[OFFTIME_BL2 ]->cur_val = stp2pvs->offtime_bl2 ;
  int_opts[ONTIME_BL2  ]->cur_val = stp2pvs->ontime_bl2  ;
  int_opts[T3SEN_SLOPE ]->cur_val = stp2pvs->t3sen_slope ;
  int_opts[T3SEN_OFFSET]->cur_val = stp2pvs->t3sen_offset;
  int_opts[MAGM_MINFLOW]->cur_val = stp2pvs->magm_minflow;
  int_opts[MAGM_MAXFLOW]->cur_val = stp2pvs->magm_maxflow;
  int_opts[MAGM_PULSE  ]->cur_val = stp2pvs->magm_pulse  ;
  int_opts[T3_MIN_DIST ]->cur_val = stp2pvs->t3_min_dist ;
  int_opts[T3_MAX_DIST ]->cur_val = stp2pvs->t3_max_dist ;
  int_opts[LIFT_MINDIST]->cur_val = stp2pvs->lift_mindist;
  int_opts[LIFT_MAXDIST]->cur_val = stp2pvs->lift_maxdist;
  int_opts[ACT_STEP_DELAY]->cur_val = stp2pvs->act_step_delay;
  int_opts[ACT_LOW_FLOW  ]->cur_val = stp2pvs->act_low_flow;
  int_opts[ACT_HIGH_FLOW ]->cur_val = stp2pvs->act_high_flow;
  //! save all options into SCADA configuration file 'bio_c.conf'
  save_bio_c_conf_bin();
  save_bio_c_conf_int();
  //! print configuration on console output, update '*.csv' files and globs
  init_config();
  
  //! resend updated OSAUT message from SCADA to PLC (hand-shake)
  update_plc_message(0,0);
}
*/
//!****************************************************************************
/*
void map_plc_config_values_to_new()
{
  //! remaping configuration from PLC OSAUT message to SCADA new config values
  //! boolean options
  bin_opts[LIFT_STATION]->new_val = stp2pvs->lift_station;
  bin_opts[LIFT_ST_ETH ]->new_val = stp2pvs->lift_eth    ;
  bin_opts[LIFT_SENSOR ]->new_val = stp2pvs->lift_sensor ;
  bin_opts[ACTUATOR_OPT]->new_val = stp2pvs->actuator_opt;
  bin_opts[ACTUATOR_ETH]->new_val = stp2pvs->actuator_eth;
  bin_opts[MAGMETER_OPT]->new_val = stp2pvs->magmeter_opt;
  bin_opts[MAGMETER_ETH]->new_val = stp2pvs->magmeter_eth;
  bin_opts[BLOWER1A_OPT]->new_val = stp2pvs->blower1a_opt;
  bin_opts[BL1A_3_PHASE]->new_val = stp2pvs->bl1a_3_phase;
  bin_opts[BL1A_S_START]->new_val = stp2pvs->bl1a_s_start;
  bin_opts[BL1A_PRES_SW]->new_val = stp2pvs->bl1a_pres_sw;
  bin_opts[BLOWER1B_OPT]->new_val = stp2pvs->blower1b_opt;
  bin_opts[BL1B_3_PHASE]->new_val = stp2pvs->bl1b_3_phase;
  bin_opts[BL1B_S_START]->new_val = stp2pvs->bl1b_s_start;
  bin_opts[BL1B_PRES_SW]->new_val = stp2pvs->bl1b_pres_sw;
  bin_opts[BLOWER2_OPT ]->new_val = stp2pvs->blower2_opt ;
  bin_opts[BL2_3_PHASE ]->new_val = stp2pvs->bl2_3_phase ;
  bin_opts[BL2_S_START ]->new_val = stp2pvs->bl2_s_start ;
  bin_opts[BL2_PRES_SW ]->new_val = stp2pvs->bl2_pres_sw ;
  bin_opts[ALTER_BLOW_2]->new_val = stp2pvs->alter_blow_2;
  bin_opts[SOLENOID_OPT]->new_val = stp2pvs->solenoid_opt;
  bin_opts[T3_SENS_OPT ]->new_val = stp2pvs->t3_sens_opt ;
  bin_opts[T3_SENS_ETH ]->new_val = stp2pvs->t3_sens_eth ;
  bin_opts[T3_HIGH_OPT ]->new_val = stp2pvs->t3_high_opt ;
  bin_opts[T3_LOW_OPT  ]->new_val = stp2pvs->t3_low_opt  ;
  bin_opts[T3_PUMP1_OPT]->new_val = stp2pvs->t3_pump1_opt;
  bin_opts[T3_PUMP2_OPT]->new_val = stp2pvs->t3_pump2_opt;
  bin_opts[ALTER_PUMPS ]->new_val = stp2pvs->alter_pumps ;
  bin_opts[UV_UNIT_OPT ]->new_val = stp2pvs->uv_unit_opt ;
  bin_opts[UV_UNIT_ETH ]->new_val = stp2pvs->uv_unit_eth ;
  bin_opts[FLOW_SW_OPT ]->new_val = stp2pvs->flow_sw_opt ;
  //! integer options
  int_opts[OFFTIME_BL1A]->new_val = stp2pvs->offtime_bl1a;
  int_opts[ONTIME_BL1A ]->new_val = stp2pvs->ontime_bl1a ;
  int_opts[OFFTIME_BL1B]->new_val = stp2pvs->offtime_bl1b;
  int_opts[ONTIME_BL1B ]->new_val = stp2pvs->ontime_bl1b ;
  int_opts[OFFTIME_BL2 ]->new_val = stp2pvs->offtime_bl2 ;
  int_opts[ONTIME_BL2  ]->new_val = stp2pvs->ontime_bl2  ;
  int_opts[T3SEN_SLOPE ]->cur_val = stp2pvs->t3sen_slope ;
  int_opts[T3SEN_OFFSET]->cur_val = stp2pvs->t3sen_offset;
  int_opts[MAGM_MINFLOW]->new_val = stp2pvs->magm_minflow;
  int_opts[MAGM_MAXFLOW]->new_val = stp2pvs->magm_maxflow;
  int_opts[MAGM_PULSE  ]->new_val = stp2pvs->magm_pulse  ;
  int_opts[T3_MIN_DIST ]->new_val = stp2pvs->t3_min_dist ;
  int_opts[T3_MAX_DIST ]->new_val = stp2pvs->t3_max_dist ;
  int_opts[LIFT_MINDIST]->new_val = stp2pvs->lift_mindist;
  int_opts[LIFT_MAXDIST]->new_val = stp2pvs->lift_maxdist;
  int_opts[ACT_STEP_DELAY]->new_val = stp2pvs->act_step_delay;
  int_opts[ACT_LOW_FLOW  ]->new_val = stp2pvs->act_low_flow;
  int_opts[ACT_HIGH_FLOW ]->new_val = stp2pvs->act_high_flow;
}
*/
//!****************************************************************************

int plc_scada_config_accordance()
{
  int dif = 0;

  //dif = (bin_opts[BUILD_ALARMS ] == ????
  //dif = (bin_opts[WATER_PLANT  ] == 
  //dif = (bin_opts[CH1A_SENSORS ] == 
  //dif = (bin_opts[CH1B_SENSORS ] == 
  //dif = (bin_opts[CH_3_SENSORS ] == 
  //dif = (bin_opts[SHOW_LVLSENS ] == 
  //dif = (bin_opts[SHOW_CH3_LVL ] == 
  //++++++++++++++++++++++ 
  //new added 
  dif =  (bin_opts[PS1_PRESENT]->cur_val == stp2pvs->PS1_present)? dif: dif+1;
  dif =  (bin_opts[PS2_PRESENT]->cur_val == stp2pvs->PS2_present)? dif: dif+1;
/*
  dif = (OPCODE_VERSION == stp2pvs->opcode )?  dif: dif+1; 
  dif = (int_opts[PLANT_ID    ]->cur_val == stp2pvs->location_id )? dif: dif+1;
  */
   /*
  dif = (bin_opts[LIFT_STATION]->cur_val == stp2pvs->lift_station)? dif: dif+1;
  dif = (bin_opts[LIFT_ST_ETH ]->cur_val == stp2pvs->lift_eth    )? dif: dif+1;
  dif = (bin_opts[LIFT_SENSOR ]->cur_val == stp2pvs->lift_sensor )? dif: dif+1;
  dif = (bin_opts[ACTUATOR_OPT]->cur_val == stp2pvs->actuator_opt)? dif: dif+1;
  dif = (bin_opts[ACTUATOR_ETH]->cur_val == stp2pvs->actuator_eth)? dif: dif+1;
  dif = (bin_opts[MAGMETER_OPT]->cur_val == stp2pvs->magmeter_opt)? dif: dif+1;
  dif = (bin_opts[MAGMETER_ETH]->cur_val == stp2pvs->magmeter_eth)? dif: dif+1;
  dif = (bin_opts[BLOWER1A_OPT]->cur_val == stp2pvs->blower1a_opt)? dif: dif+1;
  dif = (bin_opts[BL1A_3_PHASE]->cur_val == stp2pvs->bl1a_3_phase)? dif: dif+1;
  dif = (bin_opts[BL1A_S_START]->cur_val == stp2pvs->bl1a_s_start)? dif: dif+1;
  dif = (bin_opts[BL1A_PRES_SW]->cur_val == stp2pvs->bl1a_pres_sw)? dif: dif+1;
  dif = (bin_opts[BLOWER1B_OPT]->cur_val == stp2pvs->blower1b_opt)? dif: dif+1;
  dif = (bin_opts[BL1B_3_PHASE]->cur_val == stp2pvs->bl1b_3_phase)? dif: dif+1;
  dif = (bin_opts[BL1B_S_START]->cur_val == stp2pvs->bl1b_s_start)? dif: dif+1;
  dif = (bin_opts[BL1B_PRES_SW]->cur_val == stp2pvs->bl1b_pres_sw)? dif: dif+1;
  dif = (bin_opts[BLOWER2_OPT ]->cur_val == stp2pvs->blower2_opt )? dif: dif+1;
  dif = (bin_opts[BL2_3_PHASE ]->cur_val == stp2pvs->bl2_3_phase )? dif: dif+1;
  dif = (bin_opts[BL2_S_START ]->cur_val == stp2pvs->bl2_s_start )? dif: dif+1;
  dif = (bin_opts[BL2_PRES_SW ]->cur_val == stp2pvs->bl2_pres_sw )? dif: dif+1;
  dif = (bin_opts[ALTER_BLOW_2]->cur_val == stp2pvs->alter_blow_2)? dif: dif+1;
  dif = (bin_opts[SOLENOID_OPT]->cur_val == stp2pvs->solenoid_opt)? dif: dif+1;
  
  dif = (bin_opts[T3_SENS_OPT ]->cur_val == stp2pvs->t3_sens_opt )? dif: dif+1;
  dif = (bin_opts[T3_SENS_ETH ]->cur_val == stp2pvs->t3_sens_eth )? dif: dif+1;
  dif = (bin_opts[T3_HIGH_OPT ]->cur_val == stp2pvs->t3_high_opt )? dif: dif+1;
  dif = (bin_opts[T3_LOW_OPT  ]->cur_val == stp2pvs->t3_low_opt  )? dif: dif+1;
  dif = (bin_opts[T3_PUMP1_OPT]->cur_val == stp2pvs->t3_pump1_opt)? dif: dif+1;
  dif = (bin_opts[T3_PUMP2_OPT]->cur_val == stp2pvs->t3_pump2_opt)? dif: dif+1;
  dif = (bin_opts[ALTER_PUMPS ]->cur_val == stp2pvs->alter_pumps )? dif: dif+1;
  dif = (bin_opts[UV_UNIT_OPT ]->cur_val == stp2pvs->uv_unit_opt )? dif: dif+1;
  dif = (bin_opts[UV_UNIT_ETH ]->cur_val == stp2pvs->uv_unit_eth )? dif: dif+1;
  dif = (bin_opts[FLOW_SW_OPT ]->cur_val == stp2pvs->flow_sw_opt )? dif: dif+1;

  dif = (int_opts[OFFTIME_BL1A]->cur_val == stp2pvs->offtime_bl1a)? dif: dif+1;
  dif = (int_opts[ONTIME_BL1A ]->cur_val == stp2pvs->ontime_bl1a )? dif: dif+1;
  dif = (int_opts[OFFTIME_BL1B]->cur_val == stp2pvs->offtime_bl1b)? dif: dif+1;
  dif = (int_opts[ONTIME_BL1B ]->cur_val == stp2pvs->ontime_bl1b )? dif: dif+1;
  dif = (int_opts[OFFTIME_BL2 ]->cur_val == stp2pvs->offtime_bl2 )? dif: dif+1;
  dif = (int_opts[ONTIME_BL2  ]->cur_val == stp2pvs->ontime_bl2  )? dif: dif+1;
  dif = (int_opts[T3SEN_SLOPE ]->cur_val == stp2pvs->t3sen_slope )? dif: dif+1;
  dif = (int_opts[T3SEN_OFFSET]->cur_val == stp2pvs->t3sen_offset)? dif: dif+1;
  dif = (int_opts[MAGM_MINFLOW]->cur_val == stp2pvs->magm_minflow)? dif: dif+1;
  dif = (int_opts[MAGM_MAXFLOW]->cur_val == stp2pvs->magm_maxflow)? dif: dif+1;
  dif = (int_opts[MAGM_PULSE  ]->cur_val == stp2pvs->magm_pulse  )? dif: dif+1;
  dif = (int_opts[T3_MIN_DIST ]->cur_val == stp2pvs->t3_min_dist )? dif: dif+1;
  dif = (int_opts[T3_MAX_DIST ]->cur_val == stp2pvs->t3_max_dist )? dif: dif+1;
  dif = (int_opts[LIFT_MINDIST]->cur_val == stp2pvs->lift_mindist)? dif: dif+1;
  dif = (int_opts[LIFT_MAXDIST]->cur_val == stp2pvs->lift_maxdist)? dif: dif+1;
  dif = (int_opts[ACT_STEP_DELAY]->cur_val == stp2pvs->act_step_delay)? dif: dif+1;
  dif = (int_opts[ACT_LOW_FLOW  ]->cur_val == stp2pvs->act_low_flow)?   dif: dif+1;
  dif = (int_opts[ACT_HIGH_FLOW ]->cur_val == stp2pvs->act_high_flow)?  dif: dif+1;
  */
  //printf ("plc_scada_config_accordance(): dif = %d\n", dif);

  return (dif == 0);
}

/*
//!****************************************************************************
void save_config_err_info(const char *opt_name, const char *err_info,
                          int new_settings)
{
  int eve_id = (new_settings)? EVE_NEW_CONFIG_ERROR: EVE_CRITICAL_CONFIG;
  struct timeval t1, t2;
  char buf[256];
  
  if (opt_name != NULL && err_info != NULL){
     sprintf(buf,"%s: %s", opt_name, err_info);
  } else if (opt_name == NULL && err_info != NULL){
     sprintf(buf,"%s", err_info);
  } else {
     return;
  }
  usleep(5000); //! dispatcher main cycle sleeping time-out
  reset_resolved_event_requests();

  gettimeofday(&t1, NULL);
  do{
     gettimeofday(&t2, NULL);
     if (ms_diff(&t1, &t2) > 20){  //! miliseconds
        //! to avoid an issue of infinite loop
        printf ("save_config_err_info(): %s - breaked !!!\n", buf);
        break;
     }
  } while (get_event_proceeded_status(eve_id) != NO_EVENT);
  
  printf ("save_config_err_info(): %s \n", buf);
  
  event_request_info(eve_id, INIT_EVENT, buf);
}
*/
//!****************************************************************************
/*
static int int_config_err_status(int opt_id, int new_settings)
{
  int  err_num = 0;

  if(!new_settings){
     if (int_opts[opt_id]->lo_bound == 0){
        //! "Configuration critical error! Low boudary is not defined."
        save_config_err_info(IntConfigList[opt_id],LO_BOUND_NOT_DEFINED,0);     
        err_num = 1;
     } else {
        if (int_opts[opt_id]->hi_bound <= int_opts[opt_id]->lo_bound){
           //! "Configuration critical error! High boudary is incorrect."
           save_config_err_info(IntConfigList[opt_id],HI_BOUND_NOT_CORRECT,0);
           err_num = 1;
       }
     }
     if (int_opts[opt_id]->cur_val == 0){
        //! "Configuration critical error! Value is not defined."
        save_config_err_info(IntConfigList[opt_id], VALUE_IS_NOT_DEFINED, 0);     
        err_num += 1;
     } else if (int_opts[opt_id]->cur_val < int_opts[opt_id]->lo_bound ||
                int_opts[opt_id]->cur_val > int_opts[opt_id]->hi_bound ){
        //! "Configuration critical error! Value is incorrect."
        save_config_err_info(IntConfigList[opt_id], VALUE_IS_NOT_CORRECT, 0);     
        err_num += 1;
     }
  } else {
     //! skip lo_bound & hi_bound, because boundaries cannot be changed in UI
     if (int_opts[opt_id]->new_val == 0){
        //! "New config settings error! Value is not defined."
        save_config_err_info(IntConfigList[opt_id], VALUE_IS_NOT_DEFINED, 1);
        err_num += 1;
     } else if (int_opts[opt_id]->new_val < int_opts[opt_id]->lo_bound ||
                int_opts[opt_id]->new_val > int_opts[opt_id]->hi_bound ){
        //! "New config settings error! Value is incorrect."
        save_config_err_info(IntConfigList[opt_id], VALUE_IS_NOT_CORRECT,1);
        err_num += 1;
     }
  }
  return err_num;
}
*/
//!****************************************************************************
int crucial_conflict_err()
{
   int crucial_err = 0;
   int connected = !stp2pvs->no_connection;
   
   //! the condition of scada application has a crucial errors on start
   //! stp plc ip address has wrong expression in configuration file, or
   //! plant id that constantly defined in the scada program is not identical
   //! to the plant id, received from plc OSAUT message
   //????? remember to check this part....plant id
   
   /*if (connected && (int_opts[PLANT_ID]->cur_val != stp2pvs->location_id)){
      crucial_err += 1;
   }*/
   //! add more issues of the crucial contradictions...
   //printf ("crucial_conflict_err(): crucial_err = %d\n", crucial_err);
   
   return (crucial_err > 0);
}

//!****************************************************************************
int scada_cannot_be_started()
{
   int stp_ip_error = globs->stpIPerr;
   int config_error = globs->conf_err;
   int config_force = (bin_opts[CONFIG_FORCE])->cur_val;
   
   //! the condition of scada application can not be start is:
   //! the configuration file has a wrong plc ip expression, or
   //! there are some critical config errors with force-flag raised up
   
   return (stp_ip_error || (config_force && config_error));
}

//!****************************************************************************
int stp_plc_ip_error_status()
{
  struct sockaddr_in sa;
  int err = 0;
   
  if (inet_pton(AF_INET, ip_opts[STP_PLC]->ip, &(sa.sin_addr)) != 1){
     //! "Config critical error! Plant PLC ip-address is not valid."
    //++++++++++++++
     //save_config_err_info(NULL, PLC_IP_IS_NOT_VALID, 0);
     //! stp plc ip error is a crucial error, it should'nt allow SCADA to start
     globs->stpIPerr = 1;
     err += 1;
  }
  return err;
}

//!****************************************************************************
//! this function makes requests to dispatcher and works slowly
//! it should be called only in two cases: 1) on SCADA start; 
//!                    2) on trying to change and save configuration settings.
//! use the global variables values to figure out the config error status:
//! globs->conf_err; globs->stpIPerr;
//!****************************************************************************
//! parameters:'new_settings' - 0/1 boolean flag:
//!                            '0' processing current config settings 'cur_val'
//!                            '1' processing new config settings 'new_val'
//!****************************************************************************
//! returns: 0/1 '0' - no errors, '1' - error status is true
//!****************************************************************************

int config_critical_err_status(int new_settings)
{
  int err_num = 0;

  /*//! STP PLC IP ADDRESS AVAILABILITY
  if (!new_settings){
     err_num += stp_plc_ip_error_status();
  }*/
  //! PLANT-ID CONDITION
 /*if (!new_settings){
     if (int_opts[PLANT_ID]->cur_val == 0){
        //! Config error! Plant ID is not defined.
        //***need to check this later
        //save_config_err_info(IntConfigList[PLANT_ID], VALUE_IS_NOT_DEFINED, 0);
        err_num += 1;
     }
  } else {
     //! plant id number is hard-coded value and cannot be changed from UI
  }*/
  /*+++++
  ++++++++

  //! IF ACTUATOR EXISTS, MAGMETER CONDITIONS: EXISTING, MAXIMUM FLOW, PULSE
  if (!new_settings){
     if (bin_opts[ACTUATOR_OPT]->cur_val == 1){
        if (bin_opts[MAGMETER_OPT]->cur_val == 0){
           //! Config error! System with Actuator must have Magmeter.
           save_config_err_info(NULL, MAGMETER_IS_NOT_PRESENT, 0);
           err_num += 1;
        } else {
           //! Magmeter maximum flow critical errors processing
           err_num += int_config_err_status(MAGM_MAXFLOW, 0);
           //! Magmeter pulse critical errors processing
           err_num += int_config_err_status(MAGM_PULSE, 0);
        }
     }
  } else {
     if (bin_opts[ACTUATOR_OPT]->new_val == 1){
        if (bin_opts[MAGMETER_OPT]->new_val == 0){
           //! New settings error! System with Actuator must have Magmeter.
           save_config_err_info(NULL, MAGMETER_IS_NOT_PRESENT, 1);
           err_num += 1;
        } else {
           //! Magmeter maximum flow critical errors processing
           err_num += int_config_err_status(MAGM_MAXFLOW, 1);
           //! Magmeter pulse critical errors processing
           err_num += int_config_err_status(MAGM_PULSE, 1);
        }
     }
  }
  //! TANK-3 LEVEL SWITCHES
  //! level switches are read only options... anyway we have to check they exist
  if (!new_settings){
     if (!bin_opts[T3_LOW_OPT]->cur_val || !bin_opts[T3_HIGH_OPT]->cur_val){
        //! Config error! System must have Tank 3 LOW & HIGH Level Switches.
        save_config_err_info(NULL, LVL_SWITCH_MUST_HAVE, 0);
        err_num += 1;
     }
  } else {
     if (!bin_opts[T3_LOW_OPT]->new_val && !bin_opts[T3_HIGH_OPT]->new_val){
        //! New settings error! System must have Tank 3 LOW & HIGH Level Switches.
        save_config_err_info(NULL, LVL_SWITCH_MUST_HAVE, 1);
        err_num += 1;
     }
  }
  //! PUMP CONDITION
  if (!new_settings){
     if (!bin_opts[T3_PUMP1_OPT]->cur_val && !bin_opts[T3_PUMP2_OPT]->cur_val){
        //! Config error! System must have at least one discharging pump.
        save_config_err_info(NULL, PUMP_IS_NOT_PRESENT, 0);
        err_num += 1;
     }
  } else {
     if (!bin_opts[T3_PUMP1_OPT]->new_val && !bin_opts[T3_PUMP2_OPT]->new_val){
        //! New settings error! System must have at least one discharging pump.
        save_config_err_info(NULL, PUMP_IS_NOT_PRESENT, 1);
        err_num += 1;
     }
  }
  //! TANK 3 MIN/MAX WATER DISTANCES CONDITIONS
  err_num += int_config_err_status(T3_MIN_DIST, new_settings);
  err_num += int_config_err_status(T3_MAX_DIST, new_settings);
  
  //! TIMING SETTINGS
  //! Blower 1A critical errors processing
  err_num += int_config_err_status(OFFTIME_BL1A, new_settings);
  err_num += int_config_err_status(ONTIME_BL1A, new_settings);
  //! Blower 1B critical errors processing
  err_num += int_config_err_status(OFFTIME_BL1B, new_settings);
  err_num += int_config_err_status(ONTIME_BL1B, new_settings);
  //! Blower 2 critical errors processing
  err_num += int_config_err_status(OFFTIME_BL2, new_settings);
  err_num += int_config_err_status(ONTIME_BL2, new_settings);
  
  printf("scada_config_err_status(): critical config errors = %d\n", err_num);
  
  //! only place where this global 'globs->conf_err' might be defined !
  if (!new_settings){
     globs->conf_err = (err_num > 0);
  }
  */
  return (err_num > 0);
}

//!****************************************************************************
int check_plc_config_crit_errors()
{
  int plc_err_config = 0;
  //! to check if plc configuration is eligible, we temporary maping plc
  //! config settings into the 'new_val' fields in the bin_opts[] & int_opts[];
  //! then checking them for critical errors like a 'new settings' and rolling
  //! all those changes back at the end.
  //+++++++++++
  //map_plc_config_values_to_new();//comment this for now
  //++++++++
  //plc_err_config = config_critical_err_status(1);
  map_cur_config_values_to_new();
  
  return plc_err_config;
}

//!****************************************************************************
/*
void update_plc_message(int id, int v)
{
  int all_to = (id == EVE_SERVICE_ALL_TO_AUTO || id == EVE_SERVICE_ALL_TO_MAN);
  int bl1a_mode  = ( id == EVE_INTO_MAN_BL1A  || id == EVE_INTO_AUTO_BL1A  );
  int bl1b_mode  = ( id == EVE_INTO_MAN_BL1B  || id == EVE_INTO_AUTO_BL1B  );
  int bl2_mode   = ( id == EVE_INTO_MAN_BL2   || id == EVE_INTO_AUTO_BL2   );
  int pumps_mode = ( id == EVE_INTO_MAN_PUMPS || id == EVE_INTO_AUTO_PUMPS );
  int uv_mode    = ( id == EVE_INTO_MAN_UV    || id == EVE_INTO_AUTO_UV    );
  int sol_mode   = ( id == EVE_INTO_MAN_SOL   || id == EVE_INTO_AUTO_SOL   );
  int act_mode   = ( id == EVE_INTO_MAN_ACT   || id == EVE_INTO_AUTO_ACT   );
  int lift_mode  = ( id == EVE_INTO_MAN_LIFT  || id == EVE_INTO_AUTO_LIFT  );
  int serv_mode  = ( id == EVE_SERVICE_START  || id == EVE_SERVICE_FINISH  );

  int bl1a_enbl  = (id == EVE_INTO_ENBL_BL1A  || id == EVE_INTO_DIS_BL1A  );
  int bl1b_enbl  = (id == EVE_INTO_ENBL_BL1B  || id == EVE_INTO_DIS_BL1B  );
  int bl2_enbl   = (id == EVE_INTO_ENBL_BL2   || id == EVE_INTO_DIS_BL2   );
  int pump1_enbl = (id == EVE_INTO_ENBL_PUMP1 || id == EVE_INTO_DIS_PUMP1 );
  int pump2_enbl = (id == EVE_INTO_ENBL_PUMP2 || id == EVE_INTO_DIS_PUMP2 );
  int uv_enbl    = (id == EVE_INTO_ENBL_UV    || id == EVE_INTO_DIS_UV    );
  int sol_enbl   = (id == EVE_INTO_ENBL_SOL   || id == EVE_INTO_DIS_SOL   );
  int lift_enbl  = (id == EVE_INTO_ENBL_LIFT  || id == EVE_INTO_DIS_LIFT  );

  int bl1a_cmd   = (id == EVE_SWITCH_ON_BL1A  || id == EVE_SWITCH_OFF_BL1A  );
  int bl1b_cmd   = (id == EVE_SWITCH_ON_BL1B  || id == EVE_SWITCH_OFF_BL1B  );
  int bl2_cmd    = (id == EVE_SWITCH_ON_BL2   || id == EVE_SWITCH_OFF_BL2   );
  int pump1_cmd  = (id == EVE_SWITCH_ON_PUMP1 || id == EVE_SWITCH_OFF_PUMP1 );
  int pump2_cmd  = (id == EVE_SWITCH_ON_PUMP2 || id == EVE_SWITCH_OFF_PUMP2 );
  int uv_cmd     = (id == EVE_SWITCH_ON_UV    || id == EVE_SWITCH_OFF_UV    );
  int sol_cmd    = (id == EVE_SWITCH_ON_SOL   || id == EVE_SWITCH_OFF_SOL   );
  int lift_cmd   = (id == EVE_SWITCH_ON_LIFT  || id == EVE_SWITCH_OFF_LIFT  );
  
  int stop_service = (id == EVE_SERVICE_FINISH);
  
  if (id != 0){
     //printf("update_plc_message(): event id = %d\n", id);
  }
  //! preparing the data for osaut message will be sent to plc
  //! for synchronizing plc-configuration accordingly to scada
  pvs2stp->save_data_cmd = (id == EVE_CONFIG_SCADA_TO_PLC || id == EVE_CONFIG_UIMAN_TO_PLC)? v: bin_opts[CONFIG_FORCE]->cur_val;
  pvs2stp->start_plant_cmd = (id == EVE_SERVICE_STP_START)? v: stp2pvs->start_plant_stat;
  pvs2stp->stop_plant_cmd  = (id == EVE_SERVICE_STP_STOP )? v: stp2pvs->stop_plant_stat;
  pvs2stp->error_ack_cmd   = (id == EVE_SERVICE_ERR_ACK  )? v: stp2pvs->error_ack_stat;
  pvs2stp->pc_reboot_cmd   = (id == EVE_SERVICE_PC_REBOOT)? v: stp2pvs->pc_reboot_stat;
  pvs2stp->serv_mode_cmd   = (serv_mode)? v: stp2pvs->service_mode;

  pvs2stp->bl1a_manual  = (stop_service || all_to || bl1a_mode )? v: stp2pvs->bl1a_mode;
  pvs2stp->bl1b_manual  = (stop_service || all_to || bl1b_mode )? v: stp2pvs->bl1b_mode;
  pvs2stp->bl2_manual   = (stop_service || all_to || bl2_mode  )? v: stp2pvs->bl2_mode;
  pvs2stp->pumps_manual = (stop_service || all_to || pumps_mode)? v: stp2pvs->pumps_mode;
  pvs2stp->uv_manual    = (stop_service || all_to || uv_mode   )? v: stp2pvs->uv_mode;
  pvs2stp->sol_manual   = (stop_service || all_to || sol_mode  )? v: stp2pvs->sol_mode;
  pvs2stp->act_manual   = (stop_service || all_to || act_mode  )? v: stp2pvs->act_mode;
  pvs2stp->lift_manual  = (stop_service || all_to || lift_mode )? v: stp2pvs->lift_mode;

  pvs2stp->bl1a_enable  = ( bl1a_enbl  )? v: stp2pvs->bl1a_powered;
  pvs2stp->bl1b_enable  = ( bl1b_enbl  )? v: stp2pvs->bl1b_powered;
  pvs2stp->bl2_enable   = ( bl2_enbl   )? v: stp2pvs->bl2_powered;
  pvs2stp->pump1_enable = ( pump1_enbl )? v: stp2pvs->pump1_powered;
  pvs2stp->pump2_enable = ( pump2_enbl )? v: stp2pvs->pump2_powered;
  pvs2stp->uv_enable    = ( uv_enbl    )? v: stp2pvs->uv_powered;
  pvs2stp->sol_enable   = ( sol_enbl   )? v: stp2pvs->sol_powered;
  pvs2stp->lift_enable  = ( lift_enbl  )? v: stp2pvs->lift_powered;

  pvs2stp->bl1a_cmd     = ( bl1a_cmd  )? v: stp2pvs->bl1a_started;
  pvs2stp->bl1b_cmd     = ( bl1b_cmd  )? v: stp2pvs->bl1b_started;
  pvs2stp->bl2_cmd      = ( bl2_cmd   )? v: stp2pvs->bl2_started;
  pvs2stp->pump1_cmd    = ( pump1_cmd )? v: stp2pvs->pump1_started;
  pvs2stp->pump2_cmd    = ( pump2_cmd )? v: stp2pvs->pump2_started;
  pvs2stp->uv_cmd       = ( uv_cmd    )? v: stp2pvs->uv_started;
  pvs2stp->sol_cmd      = ( sol_cmd   )? v: stp2pvs->sol_started;
  pvs2stp->lift_cmd     = ( lift_cmd  )? v: stp2pvs->lift_started;

  pvs2stp->act_step_up   = (id == EVE_ACTUATOR_STEP_UP)?   v: stp2pvs->act_step_up;
  pvs2stp->act_step_down = (id == EVE_ACTUATOR_STEP_DOWN)? v: stp2pvs->act_step_down;

  pvs2stp->lift_station = bin_opts[LIFT_STATION]->cur_val;
  pvs2stp->lift_eth     = bin_opts[LIFT_ST_ETH ]->cur_val;
  pvs2stp->lift_sensor  = bin_opts[LIFT_SENSOR ]->cur_val;
  pvs2stp->actuator_opt = bin_opts[ACTUATOR_OPT]->cur_val; 
  pvs2stp->actuator_eth = bin_opts[ACTUATOR_ETH]->cur_val;
  pvs2stp->magmeter_opt = bin_opts[MAGMETER_OPT]->cur_val;
  pvs2stp->magmeter_eth = bin_opts[MAGMETER_ETH]->cur_val;
  pvs2stp->blower1a_opt = bin_opts[BLOWER1A_OPT]->cur_val;
  pvs2stp->bl1a_3_phase = bin_opts[BL1A_3_PHASE]->cur_val;
  pvs2stp->bl1a_s_start = bin_opts[BL1A_S_START]->cur_val;
  pvs2stp->bl1a_pres_sw = bin_opts[BL1A_PRES_SW]->cur_val;
  pvs2stp->blower1b_opt = bin_opts[BLOWER1B_OPT]->cur_val;
  pvs2stp->bl1b_3_phase = bin_opts[BL1B_3_PHASE]->cur_val;
  pvs2stp->bl1b_s_start = bin_opts[BL1B_S_START]->cur_val;
  pvs2stp->bl1b_pres_sw = bin_opts[BL1B_PRES_SW]->cur_val;
  pvs2stp->blower2_opt  = bin_opts[BLOWER2_OPT ]->cur_val;
  pvs2stp->bl2_3_phase  = bin_opts[BL2_3_PHASE ]->cur_val;
  pvs2stp->bl2_s_start  = bin_opts[BL2_S_START ]->cur_val;
  pvs2stp->bl2_pres_sw  = bin_opts[BL2_PRES_SW ]->cur_val;
  pvs2stp->alter_blow_2 = bin_opts[ALTER_BLOW_2]->cur_val;
  pvs2stp->solenoid_opt = bin_opts[SOLENOID_OPT]->cur_val;
  pvs2stp->t3_sens_opt  = bin_opts[T3_SENS_OPT ]->cur_val;
  pvs2stp->t3_sens_eth  = bin_opts[T3_SENS_ETH ]->cur_val;
  pvs2stp->t3_high_opt  = bin_opts[T3_HIGH_OPT ]->cur_val;
  pvs2stp->t3_low_opt   = bin_opts[T3_LOW_OPT  ]->cur_val;
  pvs2stp->t3_pump1_opt = bin_opts[T3_PUMP1_OPT]->cur_val;
  pvs2stp->t3_pump2_opt = bin_opts[T3_PUMP2_OPT]->cur_val;
  pvs2stp->alter_pumps  = bin_opts[ALTER_PUMPS ]->cur_val;
  pvs2stp->uv_unit_opt  = bin_opts[UV_UNIT_OPT ]->cur_val;
  pvs2stp->uv_unit_eth  = bin_opts[UV_UNIT_ETH ]->cur_val;
  pvs2stp->flow_sw_opt  = bin_opts[FLOW_SW_OPT ]->cur_val;

  pvs2stp->offtime_bl1a = int_opts[OFFTIME_BL1A]->cur_val;
  pvs2stp->ontime_bl1a  = int_opts[ONTIME_BL1A ]->cur_val;
  pvs2stp->offtime_bl1b = int_opts[OFFTIME_BL1B]->cur_val;
  pvs2stp->ontime_bl1b  = int_opts[ONTIME_BL1B ]->cur_val;
  pvs2stp->offtime_bl2  = int_opts[OFFTIME_BL2 ]->cur_val;
  pvs2stp->ontime_bl2   = int_opts[ONTIME_BL2  ]->cur_val;
  pvs2stp->t3sen_slope  = int_opts[T3SEN_SLOPE ]->cur_val;
  pvs2stp->t3sen_offset = int_opts[T3SEN_OFFSET]->cur_val;
  pvs2stp->magm_minflow = int_opts[MAGM_MINFLOW]->cur_val;
  pvs2stp->magm_maxflow = int_opts[MAGM_MAXFLOW]->cur_val;
  pvs2stp->magm_pulse   = int_opts[MAGM_PULSE  ]->cur_val;
  pvs2stp->t3_min_dist  = int_opts[T3_MIN_DIST ]->cur_val;
  pvs2stp->t3_max_dist  = int_opts[T3_MAX_DIST ]->cur_val;
  pvs2stp->lift_mindist = int_opts[LIFT_MINDIST]->cur_val;
  pvs2stp->lift_maxdist = int_opts[LIFT_MAXDIST]->cur_val;
  pvs2stp->act_step_delay = int_opts[ACT_STEP_DELAY]->cur_val;
  pvs2stp->act_low_flow   = int_opts[ACT_LOW_FLOW  ]->cur_val;
  pvs2stp->act_high_flow  = int_opts[ACT_HIGH_FLOW ]->cur_val;

  pvs2stp->update++;

}
*/
//!****************************************************************************

int is_an_emergency()
{
   /*return (stp2pvs->actuator_emr || stp2pvs->magmeter_emr ||
           stp2pvs->chamber3_emr || stp2pvs->pumps_emr    ||
           stp2pvs->lift_st_emr  || stp2pvs->el_power_emr ||
           stp2pvs->systoped_emr);
   */
//+++++++++ need more emergency cases
   return (stp2pvs->pump1_err && stp2pvs->pump2_err); 
}

//!****************************************************************************
/*
void show_status_message(PARAM *p, int lbl_id, int img_id)
{
  char buf[_SIZE_QK] = "";
  int unread_num = 0, type = 0;
  int crit = 0, warn = 0, info = 0;
  static int prev_type = 0;
  static int prev_num = 0;
  info_msg_t *row = NULL;
  //++++++++++++++++++++
  //if (is_an_emergency()){
  if (1){modified condition
     //! print it in red and bold font
     pvSetPaletteForegroundColor(p,lbl_id,255,0,0);
     pvSetFont(p,lbl_id,"Sans",11,1,0,0,0);

     type = ALERT_GREY_MSG_TYPE;
     sprintf(buf, " EMERGENCY ISSUE! ");

     pvSetImage(p, img_id, msg_imgs[type]);
     pvSetText(p, lbl_id, pvtr(buf));
     
  } else {
     for (int i = 0; i < msg_tbl->rows_num; i++){
         row = &(msg_tbl->rows[i]);
         if (row->selected){
            break;
         } else {
            switch (row->msg_type)
            {
              case LOG_MSG_CRIT: crit++;
                                 break;
              case LOG_MSG_WARN: warn++;
                                 break;
              case LOG_MSG_INFO: info++;
            }
            unread_num++;
         }
     }
     //! print it in black regular font
     pvSetPaletteForegroundColor(p,lbl_id,0,0,0);
     pvSetFont(p,lbl_id,"Sans",11,0,0,0,0);
     if (unread_num > 0){
        if (crit > 0) {
          type = ALERT_GREY_MSG_TYPE;
        } else if (warn > 0){
          type = WARN_GREY_MSG_TYPE;
        } else if (info > 0){
          type = INFO_GREY_MSG_TYPE;
        }
     
        if (unread_num == 1){
           sprintf(buf, " You have one new message");
        } else {
           sprintf(buf, " You have %d unread messages.", unread_num);
        }
     }
     if (prev_type != type || prev_num != unread_num){
        pvSetImage(p, img_id, msg_imgs[type]);
        pvSetText(p, lbl_id, pvtr(buf));
     
        prev_type = type;
        prev_num = unread_num;
     }
  }
}
*/
//!****************************************************************************
int config_has_new_bin_settings()
{
  int ret = 0;
  for (int i = 0; i < NUM_CONFIG_BIN; i++){
      if (bin_opts[i]->new_val != bin_opts[i]->cur_val){
         ret = 1;
         break;
      }
  }
  printf("config_has_new_bin_settings()\n");
  return ret;
}

//!****************************************************************************
int config_has_new_int_settings()
{
  int ret = 0;
  for (int i = 0; i < NUM_CONFIG_INT; i++){
      if (int_opts[i]->new_val != int_opts[i]->cur_val){
         ret = 1;
         break;
      }
  }
  printf("config_has_new_int_settings()\n");
  return ret;
}

//!****************************************************************************
int config_has_new_settings()
{
   return (config_has_new_bin_settings() || config_has_new_int_settings());
}

//!****************************************************************************
//! returns values: '1'-if succeed; '-1'-if eligible data; '0'- if no changes
//!****************************************************************************

int ui_save_new_config_setings()
{
  int config_changed   = 0;
  int connected        = !stp2pvs->no_connection;
  int bin_new_settings = config_has_new_bin_settings();
  int int_new_settings = config_has_new_int_settings();
  int new_settings     = (bin_new_settings || int_new_settings);

  //! check if changes are present:
  if (new_settings){
     //! check if changes are eligible:
     if (config_critical_err_status(1) == 0){

        if (int_new_settings){
           //! accept new integer config settings as a current values
           apply_new_int_config_changes();
           //! save integer changes into 'bio_c.conf' file
           config_changed = save_bio_c_conf_int();
        }

        if (bin_new_settings || config_changed){
           //! accept new boolean config settings as a current values
           apply_new_bin_config_changes();
           //! save bolean changes into 'bio_c.conf' file
           config_changed = save_bio_c_conf_bin();

           //! send request to dispatcher to upload changes into plc
           if (config_changed){
              if (connected){
                 event_request(EVE_CONFIG_UIMAN_TO_PLC, RUN_EVENT);
              } else {
                 event_request(EVE_NEW_CONFIG_SAVED, INIT_EVENT);
              }
              //! print configuration on console output, update '*.csv' files
              init_config();
           }
        }
     } else {
        map_cur_config_values_to_new();
        config_changed = -1;
     }
  }
  return config_changed;
}

//!****************************************************************************
void apply_new_bin_config_changes()
{
  for (int i = 0; i < NUM_CONFIG_BIN; i++){
      bin_opts[i]->cur_val = bin_opts[i]->new_val;
  }
  printf("apply_new_bin_config_changes() is called\n");
}

//!****************************************************************************
void apply_new_int_config_changes()
{
  for (int i = 0; i < NUM_CONFIG_INT; i++){
      int_opts[i]->cur_val = int_opts[i]->new_val;
  }
  printf("apply_new_int_config_changes() is called\n");
}

//!****************************************************************************
void apply_new_config_changes()
{
  apply_new_bin_config_changes();
  apply_new_int_config_changes();
}

//!****************************************************************************
void cur_to_new_bin_config()
{
  for (int i = 0; i < NUM_CONFIG_BIN; i++){
      bin_opts[i]->new_val = bin_opts[i]->cur_val;
  }
}

//!****************************************************************************
void cur_to_new_int_config()
{
  for (int i = 0; i < NUM_CONFIG_INT; i++){
      int_opts[i]->new_val = int_opts[i]->cur_val;
  }
}

//!****************************************************************************
void map_cur_config_values_to_new()
{
  cur_to_new_bin_config();
  cur_to_new_int_config();
  //int_opts[1]->new_val = int_opts[1]->cur_val;
}

//!****************************************************************************
long int  ms_diff(struct timeval *starttime, struct timeval *finishtime)
{
  long int msec;
  
  msec=(finishtime->tv_sec-starttime->tv_sec)*1000;
  msec+=(finishtime->tv_usec-starttime->tv_usec)/1000;
  return msec;
}

//!****************************************************************************
long int s_diff(struct timeval *starttime, struct timeval *finishtime)
{
  long int sec;
  
  sec=(finishtime->tv_sec-starttime->tv_sec);
  sec+=(finishtime->tv_usec-starttime->tv_usec)/1000000;
  return sec;
}

//!****************************************************************************
//! Calculating Lift Station level by Lift Level Sensor signal (m)
//!****************************************************************************
/*
double lift_st_level_value()
{
  double LIFT_ST_MAX_LVL = 5;    //! temporary, should be part of configuration
  double LIFT_ST_OFFSET  = 0.32; //! temporary, should be part of configuration
  
  double lift_st_lvl   = UNDEF_DBL;
  int show_lift_st_lvl = (int)bin_opts[LIFT_SENSOR]->cur_val;
  
  if (stp2pvs->lift_no_sign != 1 && show_lift_st_lvl == 1){
     lift_st_lvl = (((stp2pvs->lift_lvl_sens) * LIFT_ST_MAX_LVL)/
                       MAX_ANALOG_DEVICE_VAL) + LIFT_ST_OFFSET;
  }
  return lift_st_lvl;
}
*/
//!****************************************************************************
//! Calculating UV percentage intensity (0 % - 100 %)
//!****************************************************************************
/*
int uv_percent_value()
{
  int uv_intensity = UNDEF_INT;
  int show_uv      = (int)bin_opts[UV_UNIT_OPT ]->cur_val;

  if (stp2pvs->uv_no_signal != 1 && stp2pvs->uv_intensity != NO_A_SIGNAL &&
      show_uv == 1){
     uv_intensity = (((stp2pvs->uv_intensity) * 100) / MAX_ANALOG_DEVICE_VAL);
  }
  return uv_intensity;
}
*/
//!****************************************************************************
//! Calculating distance between Level Sensor and Water surface in Tank-3 (cm)
//!****************************************************************************
/*
int tank3_level_value()
{
  int level     = UNDEF_INT;
  double slope  = (double)(stp2pvs->t3sen_slope) / SEN_SLOPE_DIVIDER;
  double offset = (double)(stp2pvs->t3sen_offset)/ SEN_OFFSET_DIVIDER;
   
  if (stp2pvs->T3lvl_no_sig != 1){
     level = (int)(((stp2pvs->lvl_tank3) * slope) + offset);
     //printf("tank3_level_value: level = %d\n", level);
  }
  return level;
}
*/
//!****************************************************************************
//! Calculating income flow, measured by magmeter (cubic meters per hour)
//!****************************************************************************
double magmeter_flow_value()
{
  int max_flow = int_opts[MAX_MAGMIN_FLOW]->cur_val;
  double  flow = UNDEF_DBL;
  
  if (stp2pvs->magm_no_sign != 1){
     flow = ((double)((stp2pvs->plc_magmeter_flow)*max_flow)/MAX_ANALOG_DEVICE_VAL);
  }
  return flow;
}

//!****************************************************************************
//! Total income value, measured by magmeter (cubic meters)
//!****************************************************************************
double magmeter_total_value()
{
  double totalizer = UNDEF_DBL;
  
  if (!stp2pvs->no_connection){
      totalizer = (((double)(stp2pvs->plc_totalizer_low))/DEF_FLOW_DIVIDER);
  }
  return totalizer;
}

//!****************************************************************************
//! Calculation of actuator percent opening (0 % - 100 %)
//!****************************************************************************
/*
int actuator_formula()
{
  int percent_opening = UNDEF_INT;
  
  if (stp2pvs->act_no_sign != 1 && !stp2pvs->actuator_err){
     percent_opening = (((stp2pvs->actuator_fb)*100) / MAX_ANALOG_DEVICE_VAL);
  }
  return percent_opening;
}
*/
//!****************************************************************************
//! Temperature value, measured by sensor (degree Celsius)
//!****************************************************************************
/*
double sens_temperature_value(int dev_id)
{
  double T = UNDEF_DBL;
  sens_to_pvs_t* sens2pvs = NULL;

  switch (dev_id){
    case DEV_SENS1: sens2pvs = sens2pvs_1; break;
    case DEV_SENS2: sens2pvs = sens2pvs_2; break;
    case DEV_SENS3: sens2pvs = sens2pvs_3; break;
  }
  
  if (!sens2pvs->no_connection){
      T = (((double)(sens2pvs->temperature))/TEMPERATURE_DIVIDER);
  }
  return T;
}
*/
//!****************************************************************************
//! pH value, measured by sensor (pH units)
//!****************************************************************************
/*
double sens_pH_value(int dev_id)

{
  double pH = UNDEF_DBL;
  sens_to_pvs_t* sens2pvs = NULL;

  switch (dev_id){
    case DEV_SENS1: sens2pvs = sens2pvs_1; break;
    case DEV_SENS2: sens2pvs = sens2pvs_2; break;
    case DEV_SENS3: sens2pvs = sens2pvs_3; break;
  }
  
  if (!sens2pvs->no_connection){
      pH = (((double)(sens2pvs->pH_T_corr))/PH_VALUE_DIVIDER);
  }
  return pH;
}
*/
//!****************************************************************************
//! ORP value, measured by sensor (mV)
//!****************************************************************************
/*
double sens_orp_value(int dev_id)
{
  double orp = UNDEF_DBL;
  sens_to_pvs_t* sens2pvs = NULL;

  switch (dev_id){
    case DEV_SENS1: sens2pvs = sens2pvs_1; break;
    case DEV_SENS2: sens2pvs = sens2pvs_2; break;
    case DEV_SENS3: sens2pvs = sens2pvs_3; break;
  }
  
  if (!sens2pvs->no_connection){
      orp = (((double)(sens2pvs->orp_T_corr))/ORP_VALUE_DIVIDER);
  }
  return orp;
}
*/
//!****************************************************************************
/*int device_disconnected(int dev_id)
{
  int disconnected   = (dev_id == DEV_SYS)? 0: 1;
  int stp_connected  = !(stp2pvs->no_connection);
  int sen1_connected = 0;
  int sen2_connected = 0;
  int sen3_connected = 0;

  if (dev_id != DEV_SYS){
     if (bin_opts[CH1A_SENSORS]->cur_val == 1){
        sen1_connected = !(sens2pvs_1->no_connection);
     }
     if (bin_opts[CH1B_SENSORS]->cur_val == 1){
        sen2_connected = !(sens2pvs_2->no_connection);
     }
     if (bin_opts[CH_3_SENSORS]->cur_val == 1){
        sen3_connected = !(sens2pvs_3->no_connection);
     }
  
     disconnected = (!sen1_connected && dev_id == DEV_SENS1) ||
                    (!sen2_connected && dev_id == DEV_SENS2) ||
                    (!sen3_connected && dev_id == DEV_SENS3) ||
                    (dev_id != DEV_SENS1 && dev_id != DEV_SENS2 &&
                     dev_id != DEV_SENS3 && !stp_connected);
  }
  return disconnected;
}
*/
int device_disconnected(int dev_id)
{
  ///int disconnected   = (dev_id == DEV_SYS)? 0: 1;
  ///temperory write below
  int disconnected = 0;
  int stp_connected  = !(stp2pvs->no_connection);
  ///if (dev_id != DEV_SYS){
     disconnected = 
                    (!stp_connected);
  ///}
  return disconnected;
}

//!****************************************************************************
int device_in_err_status(int dev_id)
{
  int i = 0, err_stat = 0;
   
  for (i = 0; i < MAX_DEV_NUM; i++){
      if (devstatList[i]->dev_id == dev_id){
         err_stat = devstatList[i]->in_err;
         break;
      }
  }
  if (i == MAX_DEV_NUM){
     printf ("device_in_err_status() ERROR: unrecognized device ID\n");
  }
  return err_stat;
}

//!****************************************************************************
int is_production_mode()
{
  int in_production = stp2pvs->sys_runstat;

  return in_production;
}

//!****************************************************************************
int is_sys_error_mode()
{
  int is_sys_error = (stp2pvs->warn_error || stp2pvs->crit_error);
  
  return is_sys_error;
}

//!****************************************************************************
//! PROCESSING CLIENTS CONNECTED TO SCADA API: START
//!****************************************************************************
void init_client_adr(PARAM *p)
{
  if (p == NULL) return;

  struct sockaddr_in *sockaddr_in_ptr  = (sockaddr_in *) &pvSockaddr;
  if(sockaddr_in_ptr->sin_family == AF_INET){
     char adr[64];
     unsigned int *ipadr_ptr, ipadr, a1, a2, a3, a4;

     ipadr_ptr = (unsigned int *) &sockaddr_in_ptr->sin_addr;
     ipadr = *ipadr_ptr;
     unsigned char *uc = (unsigned char *) ipadr_ptr;
  
     a1 = uc[0];
     a2 = uc[1];
     a3 = uc[2];
     a4 = uc[3];
  
     sprintf(adr,"%d.%d.%d.%d", a1,a2,a3,a4);

     for (int i = 0; i < MAX_NUM_CLIENTS; i++){
         if (connected_clients[i].s == p->s){
            strcpy(connected_clients[i].ip_adr,adr);
            printf("ipv_adr =v%s\n",connected_clients[i].ip_adr);
            break;
         }
     }
  }
}

//!****************************************************************************
int set_client_service_mode(int s, int new_service_mode)
{
  char msg[_SIZE_QK];
  int client_ind = -1, old_service_mode, status = 0;
  
  monitoring_clients();
  for (int i = 0; i < MAX_NUM_CLIENTS; i++){
      if (connected_clients[i].s == s){
         client_ind = i;
      }
      if ((new_service_mode == OPERATING || new_service_mode == SERVICE) &&
         connected_clients[i].service_mode == new_service_mode){
         if (connected_clients[i].service_mode == OPERATING){
            strcpy(msg, OPERATOR_ALREADY_ON);
         } else if (connected_clients[i].service_mode == SERVICE){
            strcpy(msg, SERVICE_ALREADY_ON);
         }
         printf("set_client_service_mode(): %s\n",msg);
         status = -1;
      }
  }
  
  if (status != -1 && client_ind != -1){
     old_service_mode = connected_clients[client_ind].service_mode;
     connected_clients[client_ind].service_mode = new_service_mode;
     if (strcmp(connected_clients[client_ind].ip_adr, LOCAL_IP_ADR) != 0 &&
         new_service_mode == SERVICE){
        block_local_client = 1;
     }
     if (old_service_mode == SERVICE){
        block_local_client = 0;
     }
     status = 1;
  }
  return status;
}

//!****************************************************************************
/*
int remove_client_disconnected(int s)
{
  int status = -1;
  
  for (int i = 0; i < MAX_NUM_CLIENTS; i++){
      if (connected_clients[i].s == s){

         if (connected_clients[i].service_mode == SERVICE){
            block_local_client = 0;
         }
         
         event_request_info(EVE_CLIENT_DISCONNECTED, INIT_EVENT,
                                           connected_clients[i].ip_adr);
         connected_clients[i].s = 0;
         connected_clients[i].service_mode = UNSIGNED;
         strcpy(connected_clients[i].ip_adr,"");
         status = 0;
         break;
      }
  }
  return status;
}
*/
//!****************************************************************************
int add_client_connected(int s)
{
  int status = -1;
  for (int i = 0; i < MAX_NUM_CLIENTS; i++){
      if (connected_clients[i].s == 0){
         connected_clients[i].s = s;
         status = i;
         break;
      }
  }
  return status;
}

//!****************************************************************************
int get_num_clients_connected()
{
  int num = 0;
  for (int i = 0; i < MAX_NUM_CLIENTS; i++){
      if (connected_clients[i].s != 0){
         num++;
      }
  }
  return num;
}

//!****************************************************************************
void monitoring_clients()
{
  int client_connected;
  ConnectedClient *client;

  pvAddressTable* client_tbl = NULL;
  client_tbl = (pvAddressTable *)pvGetAdrTableItem();

  for (int j = 0; j < MAX_NUM_CLIENTS; j++){
     client_connected = 0;
     client = &(connected_clients[j]);
     for (int i = 0; i < MAX_CLIENTS; i++){
         if (client->s == client_tbl->adr[i].s){
            client_connected = 1;
            //printf("s = %d, adress = %s\n", client_tbl->adr[i].s, client_tbl->adr[i].adr);
            break;
         }
     }
     
     if (!client_connected){
      //++++++++++++++++++++
        //remove_client_disconnected(client->s);
     }
  }
}

//!****************************************************************************
void close_unloged_client(int s, char *ip_adr)
{
  set_client_service_mode(s, UNSIGNED);
  //++++++++++++++
  //event_request_info(EVE_CLIENT_LOGGED_OUT, INIT_EVENT, ip_adr);
  monitoring_clients();
}

//!****************************************************************************
//! SESSION: client connection type recognition and mask data initialization
//!****************************************************************************
void init_user_session(PARAM *p, ClientSession *session)
{
  if (p == NULL || session == NULL) return;
  
  session->client = (ConnectedClient *)(p->user);
  gettimeofday(&(session->last_time_active), 0);

  if (strcmp(session->client->ip_adr, LOCAL_IP_ADR) == 0){
     session->connection_type = LOCAL_HOST_TYPE;
  } else {
     session->connection_type = REMOTE_HOST_TYPE;
  }
}

//!****************************************************************************
//! SESSION: monitoring remote client connection & terminating it on timeout 
//!****************************************************************************
int observer_timeout_monitoring(PARAM *p, int imgBlock_id, int lblUpStat_id,
                                 ClientSession *session)
{
  char buf[256];
  struct timeval cur_time;
  ConnectedClient *client = NULL;

  if (p == NULL || session == NULL) return -1;

  client = session->client;
  //!-----------------------------------------------------------------  
  //! closing remote OBSERVER session UI due to time out 
  //!----------------------------------------------------------------- 
  if (session->connection_type == REMOTE_HOST_TYPE &&
      (client->service_mode == OBSERVING || client->service_mode == UNSIGNED)){
     gettimeofday(&cur_time, 0);     
     if (cur_time.tv_sec - session->last_time_active.tv_sec > SESSION_TIMEOUT){
    
        pvSetGeometry(p, imgBlock_id, 1, 1, 800, 600);
        strcpy(buf, SESSION_TIMED_OUT);
        pvSetText(p, lblUpStat_id, pvtr(buf));
        //+++++++++++
        //event_request_info(EVE_SESSION_TIMED_OUT, INIT_EVENT, client->ip_adr);
        sprintf(buf, MSG_SESSION_TIMED_OUT, client->ip_adr);
        pvThreadFatal(p, buf);    
     }
  }
  return 0;
}
//!****************************************************************************
//! PROCESSING CLIENTS CONNECTED TO SCADA API: END
//!****************************************************************************

//!****************************************************************************
/*
int get_stp_sensors_state()
{
  int state = UNIT_DCN;
  
  if (!device_disconnected(DEV_SENS1) ||
      !device_disconnected(DEV_SENS2) || !device_disconnected(DEV_SENS3)){
     state = UNIT_ACTIVE;
  } 
  return state;
}
*/

//!****************************************************************************
//! COMBOBOX PROCESSING API: START
//!****************************************************************************
int list_length(const char **List)
{
  int n = 0;
  
  if (List != NULL){
      while (strcmp("",List[++n]) != 0);
  }
  return n;
}

//!****************************************************************************
void remove_combo_item_by_index(PARAM *p, int id, const char **List, int index)
{
   pvRemoveItemByName(p, id, List[index]);
}

//!****************************************************************************
void fill_combo_from_list(PARAM *p, int cmb_id, const char **List, int cur_item)
{
  int list_size = 0;
  
  if(p == NULL || List == NULL) return;

  list_size = list_length(List);
  
  if (list_size > 0){
     for (int i = list_size-1; i >=0; i--){
         pvInsertItem (p, cmb_id, 0, NULL, List[i], 0);
     }
     pvSetCurrentItem(p, cmb_id, cur_item);
  }
}

//!****************************************************************************
int get_combo_index(const char **comboList, const char *text)
{
  int result = UNDEF_INT;
  int ind = 0;
  
  if (comboList != NULL && text != NULL){
      do{
          if (strcmp(text, comboList[ind]) == 0){
            result = ind;
            break;
          }
          ind++;
      }while (strcmp("",comboList[ind]) != 0);
  }
  return result;
}

//!****************************************************************************
//! COMBOBOX PROCESSING API: END
//!****************************************************************************
//!****************************************************************************
//!                    EXTERNAL EVENT REQUESTS API
//!----------------------------------------------------------------------------
//! reset_event_requests(): switches off statuses all events has been resolved 
//!----------------------------------------------------------------------------
//! no args
//!****************************************************************************
//++++++++  get from dispatcher.cpp
/*void reset_resolved_event_requests()
{
  int  i = 0;
  do {
    if (event_ind_resolved(i)){
       (eve_request[i])->event_go = NO_EVENT;
       strcpy((eve_request[i])->eve_info, EMPTY_STRING);
       (eve_request[i])->event_val = UNDEF_INT;
    }
  } while ((eve_request[++i])->event_id != EVE_MAX_NUMBER);
}
*/